<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cqjoker&#39;s Blog</title>
  
  <subtitle>奶瓶大叔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cqjokers.top/"/>
  <updated>2018-08-14T08:53:45.795Z</updated>
  <id>https://cqjokers.top/</id>
  
  <author>
    <name>cqjokers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot (七)Mybatis的整合</title>
    <link href="https://cqjokers.top/note/2018/08/14/8b2a3900.html"/>
    <id>https://cqjokers.top/note/2018/08/14/8b2a3900.html</id>
    <published>2018-08-14T08:52:33.000Z</published>
    <updated>2018-08-14T08:53:45.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/14/5b729814549fb.jpg" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>在之前的<a href="https://cqjokers.top/note/2018/08/08/170f521.html">工程创建</a>基础上勾选上MySql与Mybatis如图所示：<img src="https://i.loli.net/2018/08/14/5b728838bcee0.png" alt="">项目创建好后发现POM.xml中多了以下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>按照平时开发的套路创建项目结构，如下图所示：<img src="https://i.loli.net/2018/08/14/5b7289b2205fd.png" alt="">这里并没有创建dao层，后面将进行说明。<br><a id="more"></a></p><h1 id="MyBatis-Generator配置"><a href="#MyBatis-Generator配置" class="headerlink" title="MyBatis Generator配置"></a>MyBatis Generator配置</h1><h2 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h2><p>首先在pom.xml中添加插件配置，如下所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.5&lt;/version&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt; mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt; mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt; 5.1.39&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;generate&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--允许移动生成的文件 --&gt;</span><br><span class="line">&lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class="line">&lt;!-- 是否覆盖 --&gt;</span><br><span class="line">&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">&lt;!-- mybatis-generator配置文件路径 --&gt;</span><br><span class="line">&lt;configurationFile&gt;</span><br><span class="line">src/main/resources/mybatis-generator/mybatis-generator.xml&lt;/configurationFile&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><h2 id="mybatis-generator配置文件创建"><a href="#mybatis-generator配置文件创建" class="headerlink" title="mybatis-generator配置文件创建"></a>mybatis-generator配置文件创建</h2><p>在resources目录中新建一个mybatis-generator目录并在其中创建一个<code>mybatis-generator.xml</code>文件，其内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=<span class="string">"mybatis-generator/mybatisGenerator.properties"</span>/&gt;</span><br><span class="line">    &lt;context id=<span class="string">"memberTables"</span> targetRuntime=<span class="string">"MyBatis3"</span>&gt;</span><br><span class="line">        &lt;!-- 自动识别数据库关键字，默认<span class="keyword">false</span>，如果设置为<span class="keyword">true</span>，根据SqlReservedWords中定义的关键字列表；</span><br><span class="line">            一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"autoDelimitKeywords"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">        &lt;!-- 生成的Java文件的编码 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"javaFileEncoding"</span> value=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"beginningDelimiter"</span> value=<span class="string">"`"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"endingDelimiter"</span> value=<span class="string">"`"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 格式化java代码 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"javaFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;</span><br><span class="line">        &lt;!-- 格式化XML代码 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"xmlFormatter"</span> value=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;</span><br><span class="line">        &lt;plugin type=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;plugin type=<span class="string">"org.mybatis.generator.plugins.ToStringPlugin"</span>/&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 <span class="keyword">true</span>：是 ： <span class="keyword">false</span>:否 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"suppressAllComments"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=<span class="string">"$&#123;jdbc_driver&#125;"</span></span><br><span class="line">                        connectionURL=<span class="string">"$&#123;jdbc_url&#125;"</span></span><br><span class="line">                        userId=<span class="string">"$&#123;jdbc_user&#125;"</span></span><br><span class="line">                        password=<span class="string">"$&#123;jdbc_password&#125;"</span>&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 默认<span class="keyword">false</span>，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 <span class="keyword">true</span>时把JDBC DECIMAL 和</span><br><span class="line">                NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=<span class="string">"forceBigDecimals"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=<span class="string">"$&#123;po_package&#125;"</span> targetProject=<span class="string">"$&#123;project&#125;"</span>&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"trimStrings"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=<span class="string">"mappers"</span> targetProject=<span class="string">"$&#123;resource&#125;"</span>&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=<span class="string">"XMLMAPPER"</span> targetPackage=<span class="string">"$&#123;mapper_package&#125;"</span> targetProject=<span class="string">"$&#123;project&#125;"</span>&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"enableSubPackages"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;table tableName=<span class="string">"t_user"</span> enableCountByExample=<span class="string">"false"</span> enableUpdateByExample=<span class="string">"false"</span></span><br><span class="line">               enableDeleteByExample=<span class="string">"false"</span></span><br><span class="line">               enableSelectByExample=<span class="string">"false"</span> selectByExampleQueryId=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p><p>在文件首部引用了一个<code>mybatisGeneratorinit.properties</code>文件，会使用其中的属性值来设置配置中相关属性，配置中的table是需要自动生成代码的数据表，可以添加多个。</p><h2 id="mybatisGenerator-properties创建"><a href="#mybatisGenerator-properties创建" class="headerlink" title="mybatisGenerator.properties创建"></a>mybatisGenerator.properties创建</h2><p>在resources目录中的mybatis-generator目录中创建一个<code>mybatisGenerator.properties</code>文件其内容如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project=src/main/java</span><br><span class="line">resource=src/main/resources</span><br><span class="line">po_package=top.cqjokers.sbl.pojo</span><br><span class="line">mapper_package=top.cqjokers.sbl.mapper</span><br><span class="line">jdbc_driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc_url=jdbc:mysql:<span class="comment">//localhost:3306/sbl?tinyInt1isBit=false</span></span><br><span class="line">jdbc_user=root</span><br><span class="line">jdbc_password=root</span><br></pre></td></tr></table></figure></p><p>该文件主要是配置了自动生成的实体类所在位置与mapper的位置及数据库连接信息。</p><h2 id="生成代码与mapper的xml"><a href="#生成代码与mapper的xml" class="headerlink" title="生成代码与mapper的xml"></a>生成代码与mapper的xml</h2><p>创建mybatisGenerator的运行配置，如下图所示：<img src="https://i.loli.net/2018/08/14/5b728dd6e9cfc.png" alt=""><img src="https://i.loli.net/2018/08/14/5b728e1773050.png" alt="">创建好后直接运行若出现下图示例则代表代码生成成功：<img src="https://i.loli.net/2018/08/14/5b728e909b5a1.png" alt="">这时会发现工程的结构有所变化，多了pojo、mapper包，resources目录中多了一个mappers目录。其工程结构如下所示：<img src="https://i.loli.net/2018/08/14/5b728f1190669.png" alt="">到此自动生成代码就结束。</p><h1 id="application-yml的配置"><a href="#application-yml的配置" class="headerlink" title="application.yml的配置"></a>application.yml的配置</h1><p>代码生在好后在使用mybatis之前需要对其进行相关配置，如下面所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9090</span></span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/sbl?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    username: root</span><br><span class="line">    password:</span><br><span class="line">mybatis:</span><br><span class="line">  type-aliases-<span class="keyword">package</span>: top.cqjokers.sbl.mapper</span><br><span class="line">  mapper-locations: classpath:mappers<span class="comment">/*Mapper.xml</span></span><br><span class="line"><span class="comment">  configuration:</span></span><br><span class="line"><span class="comment">    call-setters-on-nulls: true</span></span><br></pre></td></tr></table></figure></p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>在<code>TUserMapper</code>中添加一个<code>selectUsers</code>方法这里使用mybatis的注解方式，目的是想与xml配置方式区别开来，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TUserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(TUser record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(TUser record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TUser <span class="title">selectByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(TUser record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(TUser record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from t_user"</span>)</span><br><span class="line">    <span class="function">List&lt;TUser&gt; <span class="title">selectUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在顶部加入了<code>Mapper</code>注解，如果不使用它则需要在启动类上加入<code>MapperScan</code>注解并填入Mapper包的路径<br>Service代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TUserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TUser&gt; <span class="title">selectUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TUser <span class="title">selectUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByPrimaryKey(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>controller代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;TUser&gt; userList = userService.selectUsers();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.selectUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>编写测试类如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes=SblApplication.class,webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SblApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SblApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询单个</span></span><br><span class="line">        ResponseEntity&lt;TUser&gt; responseEntity =  template.getForEntity(<span class="string">"http://localhost:9090/user/&#123;id&#125;"</span>,TUser.class,<span class="number">2</span>);</span><br><span class="line">        logger.info(responseEntity.getBody().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        ResponseEntity&lt;List&lt;TUser&gt;&gt; responseEntity1 = template.exchange(<span class="string">"http://localhost:9090/users"</span>, HttpMethod.GET, <span class="keyword">null</span>, <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;TUser&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.info(responseEntity1.getBody().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行测试类如果在控制台看到以下日志则代码成功：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top.cqjokers.sbl.SblApplication:TUser [Hash = <span class="number">441260727</span>, id=<span class="number">2</span>, username=测试, password=<span class="number">123</span>, tel=<span class="number">11321316532132</span>, nickname=<span class="number">123</span>, serialVersionUID=<span class="number">1</span>]</span><br><span class="line">top.cqjokers.sbl.SblApplication:[TUser [Hash = <span class="number">2054332292</span>, id=<span class="number">1</span>, username=cqjokers, password=<span class="number">123</span>, tel=<span class="number">12345678901</span>, nickname=大叔, serialVersionUID=<span class="number">1</span>], TUser [Hash = <span class="number">507944445</span>, id=<span class="number">2</span>, username=测试, password=<span class="number">123</span>, tel=<span class="number">11321316532132</span>, nickname=<span class="number">123</span>, serialVersionUID=<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果mapper的xml文件不是放在resources中的话，那么在打包的时候一定要将xml一并打包进去否则打包后运行的项目会出现问题</p><p>该文的示例地址：<a href="https://github.com/cqjokers/Spring-Boot-Learning" target="_blank" rel="noopener">https://github.com/cqjokers/Spring-Boot-Learning</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/14/5b729814549fb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;h1 id=&quot;项目创建&quot;&gt;&lt;a href=&quot;#项目创建&quot; class=&quot;headerlink&quot; title=&quot;项目创建&quot;&gt;&lt;/a&gt;项目创建&lt;/h1&gt;&lt;p&gt;在之前的&lt;a href=&quot;https://cqjokers.top/note/2018/08/08/170f521.html&quot;&gt;工程创建&lt;/a&gt;基础上勾选上MySql与Mybatis如图所示：&lt;img src=&quot;https://i.loli.net/2018/08/14/5b728838bcee0.png&quot; alt=&quot;&quot;&gt;项目创建好后发现POM.xml中多了以下依赖：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;按照平时开发的套路创建项目结构，如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/14/5b7289b2205fd.png&quot; alt=&quot;&quot;&gt;这里并没有创建dao层，后面将进行说明。&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
      <category term="mybatis" scheme="https://cqjokers.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Redis ＂MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk＂问题</title>
    <link href="https://cqjokers.top/note/2018/08/14/9ef81304.html"/>
    <id>https://cqjokers.top/note/2018/08/14/9ef81304.html</id>
    <published>2018-08-14T05:36:22.000Z</published>
    <updated>2018-08-14T05:37:46.083Z</updated>
    
    <content type="html"><![CDATA[<p>今天中午，朋友说之前我做的那个外包项目客户那边说数据不对。于是马上登录服务器把日志下载下来查看原因，查看日志发现出现了如下图所示的问题：<img src="https://i.loli.net/2018/08/14/5b72656d33de9.png" alt="">日志里出现了大量的”MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.”错误，于是再去查看redis日志，发现出现了”Can’t save in background: fork: Cannot allocate memory”错误提示。对于第一条错误，网上很多都是“config set stop-writes-on-bgsave-error no”但这样做仅仅是忽略了这个异常，使得程序能够继续往下运行，但实际上还是会失败！再查看redis日志的时候还发现了一条这样的提示：<img src="https://i.loli.net/2018/08/14/5b726772228fb.png" alt="">（警告：过量使用内存设置为0！在低内存环境下，后台保存可能失败。为了修正这个问题，请在/etc/sysctl.conf 添加一项 ‘vm.overcommit_memory = 1’ ，然后重启（或者运行命令’sysctl vm.overcommit_memory=1’ ）使其生效。）这样的提示在我的印象中好像基本上每次重启redis的时候都有出现，但当时都是直接忽略掉并没有放在心上。结合这条提示大概就能明白为什么会出现”Can’t save in background: fork: Cannot allocate memory”的错误，人家明明都已经提示了而我却没有引起注意只能怪自己太SB，最后按照提示进行修改，在<code>/etc/sysctl.conf</code>中加入<code>vm.overcommit_memory=1</code>保存后并执行命令<code>sysctl vm.overcommit_memory=1</code>使其生效，重启redis后即可，至于<code>vm.overcommit_memory=1</code>这是干嘛用的就只有去问娘了。</p><blockquote><p>内核参数overcommit_memory<br>它是 内存分配策略<br>可选值：0、1、2。<br>0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br>1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2， 表示内核允许分配超过所有物理内存和交换空间总和的内存</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天中午，朋友说之前我做的那个外包项目客户那边说数据不对。于是马上登录服务器把日志下载下来查看原因，查看日志发现出现了如下图所示的问题：&lt;img src=&quot;https://i.loli.net/2018/08/14/5b72656d33de9.png&quot; alt=&quot;&quot;&gt;日志里
      
    
    </summary>
    
      <category term="错误分析" scheme="https://cqjokers.top/categories/%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="redis" scheme="https://cqjokers.top/tags/redis/"/>
    
      <category term="error" scheme="https://cqjokers.top/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (六)Servlet、Filter、Listener配置</title>
    <link href="https://cqjokers.top/note/2018/08/13/38067409.html"/>
    <id>https://cqjokers.top/note/2018/08/13/38067409.html</id>
    <published>2018-08-13T09:41:27.000Z</published>
    <updated>2018-08-13T09:44:13.560Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/13/5b7151d0be8bb.jpg" alt=""><br>SpringBoot对Servlet、Filter、Listener的配置有两种方式：<br>1、注解方式<br>2、代码注册方式</p><h1 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h1><p>通过注解方式，需要在启动类上加入<code>@ServletComponentScan</code>注解，具体配置项如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ServletComponentScanRegistrar.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServletComponentScan &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>新建一个IndexServlet，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"IndexServlet"</span>,urlPatterns = <span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(IndexServlet.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;进入IndexServlet&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        pw.print(<span class="string">"这是由IndexServlet返回"</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要在类上加上<code>WebServlet</code>注解并对相关配置项进行设置</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>新建一个LoginFilter,代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>,filterName = <span class="string">"loginFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;LoginFilter init...&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;LoginFilter doFilter...&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要在类上加上<code>WebFilter</code>注解并对相关配置项进行设置</p><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>新建一个IndexListener，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(IndexListener.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;IndexListener contextInitialized&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;IndexListener contextDestroyed&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要在类上加上<code>WebListener</code>注解<br><a id="more"></a></p><h1 id="代码注册方式"><a href="#代码注册方式" class="headerlink" title="代码注册方式"></a>代码注册方式</h1><p>SpringBoot提供了三种Bean，FilterRegistrationBean、ServletRegistrationBean、ServletListenerRegistrationBean分别对应配置原生的Filter、Servlet、Listener。</p><h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">indexServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">        bean.setServlet(<span class="keyword">new</span> IndexServlet());</span><br><span class="line">        bean.addUrlMappings(<span class="string">"/index"</span>);</span><br><span class="line">        <span class="keyword">return</span>  bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">loginFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> LoginFilter());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener-1"><a href="#Listener-1" class="headerlink" title="Listener"></a>Listener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">indexListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletListenerRegistrationBean bean = <span class="keyword">new</span> ServletListenerRegistrationBean();</span><br><span class="line">        bean.setListener(<span class="keyword">new</span> IndexListener());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的情况下通过代码方式得到的结果应该与注解方式一样。最后附上项目的结构图：<br><img src="https://i.loli.net/2018/08/13/5b714d05e3ab5.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过运行结果可以知道，这三者处理顺序是listener-&gt;filter-&gt;servlet,通过注解方式其实最终都会转换成这三种bean的FilterRegistrationBean、ServletRegistrationBean、ServletListenerRegistrationBean。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/13/5b7151d0be8bb.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;SpringBoot对Servlet、Filter、Listener的配置有两种方式：&lt;br&gt;1、注解方式&lt;br&gt;2、代码注册方式&lt;/p&gt;
&lt;h1 id=&quot;注解方式&quot;&gt;&lt;a href=&quot;#注解方式&quot; class=&quot;headerlink&quot; title=&quot;注解方式&quot;&gt;&lt;/a&gt;注解方式&lt;/h1&gt;&lt;p&gt;通过注解方式，需要在启动类上加入&lt;code&gt;@ServletComponentScan&lt;/code&gt;注解，具体配置项如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Import&lt;/span&gt;(&amp;#123;ServletComponentScanRegistrar.class&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; ServletComponentScan &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;basePackages&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String[] value() &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String[] basePackages() &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;?&amp;gt;[] basePackageClasses() &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;新建一个IndexServlet，代码如下所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@WebServlet&lt;/span&gt;(name = &lt;span class=&quot;string&quot;&gt;&quot;IndexServlet&quot;&lt;/span&gt;,urlPatterns = &lt;span class=&quot;string&quot;&gt;&quot;/index&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IndexServlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HttpServlet&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(IndexServlet.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doGet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(HttpServletRequest req, HttpServletResponse resp)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ServletException, IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logger.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;进入IndexServlet&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resp.setCharacterEncoding(&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PrintWriter pw = resp.getWriter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pw.print(&lt;span class=&quot;string&quot;&gt;&quot;这是由IndexServlet返回&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pw.flush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pw.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要在类上加上&lt;code&gt;WebServlet&lt;/code&gt;注解并对相关配置项进行设置&lt;/p&gt;
&lt;h2 id=&quot;Filter&quot;&gt;&lt;a href=&quot;#Filter&quot; class=&quot;headerlink&quot; title=&quot;Filter&quot;&gt;&lt;/a&gt;Filter&lt;/h2&gt;&lt;p&gt;新建一个LoginFilter,代码如下所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@WebFilter&lt;/span&gt;(urlPatterns = &lt;span class=&quot;string&quot;&gt;&quot;/*&quot;&lt;/span&gt;,filterName = &lt;span class=&quot;string&quot;&gt;&quot;loginFilter&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LoginFilter&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Filter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LoginFilter.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logger.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;LoginFilter init...&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logger.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;LoginFilter doFilter...&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        filterChain.doFilter(servletRequest,servletResponse);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要在类上加上&lt;code&gt;WebFilter&lt;/code&gt;注解并对相关配置项进行设置&lt;/p&gt;
&lt;h2 id=&quot;Listener&quot;&gt;&lt;a href=&quot;#Listener&quot; class=&quot;headerlink&quot; title=&quot;Listener&quot;&gt;&lt;/a&gt;Listener&lt;/h2&gt;&lt;p&gt;新建一个IndexListener，代码如下所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@WebListener&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IndexListener&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ServletContextListener&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(IndexListener.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contextInitialized&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ServletContextEvent servletContextEvent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logger.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;IndexListener contextInitialized&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contextDestroyed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ServletContextEvent servletContextEvent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        logger.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;IndexListener contextDestroyed&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要在类上加上&lt;code&gt;WebListener&lt;/code&gt;注解&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
      <category term="servlet" scheme="https://cqjokers.top/tags/servlet/"/>
    
      <category term="filter" scheme="https://cqjokers.top/tags/filter/"/>
    
      <category term="listener" scheme="https://cqjokers.top/tags/listener/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (五)Thymeleaf模板的整合</title>
    <link href="https://cqjokers.top/note/2018/08/13/27afc888.html"/>
    <id>https://cqjokers.top/note/2018/08/13/27afc888.html</id>
    <published>2018-08-13T06:58:18.000Z</published>
    <updated>2018-08-13T06:59:51.213Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/13/5b712bc101a4c.jpg" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的开发中用到最多的就是JSP，Spring MVC里面也可以很方便的将JSP与一个View关联起来，使用还是非常方便的。但是把一个传统的Spring MVC项目转为一个Spring Boot项目后，却发现JSP和view关联有些麻烦，因为官方不推荐JSP在Spring Boot中使用。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先在 <code>pom.xml</code> 中添加对 <code>thymeleaf</code> 模板依赖<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>这里使用上一次新建的工程(<a href="https://cqjokers.top/note/2018/08/10/ec5b638f.html">参考地址</a>)在些基础上加入<code>Thymeleaf</code>,在templaes目录中建立一个user.html模版，如下图所示：<a id="more"></a><img src="https://i.loli.net/2018/08/13/5b711c9038720.png" alt="">为什么要在templaes目录中新建模版后面会进行说明，新建模版后在顶部加入命名空间<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code>，将静态转化为动态的视图，需要进行动态处理的元素使用“th:”前缀。<code>user.html</code>模版内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>账号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>昵称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;userList&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.username&#125;"</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.nickname&#125;"</span>&gt;</span>1990-06-01<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在原来的基础上对<code>UserController</code>进行修改，内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        ModelAndView view = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        UserInfo userInfo = userService.getUserById(id);</span><br><span class="line">        view.addObject(<span class="string">"user"</span>,userInfo);</span><br><span class="line">        <span class="keyword">return</span>  view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"user"</span>);</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = userService.getAllUser();</span><br><span class="line">        view.addObject(<span class="string">"userList"</span>,userInfoList);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在浏览器中通过<code>localhost:9090/users</code>访问，如果出现以下页面则代码成功：<img src="https://i.loli.net/2018/08/13/5b7120154463e.png" alt="">这里只提供了users的模版，未提供访问单个user的模版。假如现在我在没有重启服务器的情况下对模版进行了修改，刷新浏览器会发现没有任何改变，要想使模版修改后立即生效可以在配置中添加<code>spring.thymeleaf.cache=false</code>这样就能够马上生效，还有一种方式就是依赖<code>spring-boot-devtools</code>热部署模块来达到同样的效果。</p><h1 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h1><p>在SpringBoot中默认情况下为我们做了如下的默认配置工作，配置如下图所示：<img src="https://i.loli.net/2018/08/13/5b712213d2f4c.png" alt="">通过上面的图就可以说明为什么模版必须放在templates中了，当然也可以放到其它位置，只需要对配置进行修改即可。Spring Boot集成Thymeleaf是通过org.springframework.boot.autoconfigure.thymeleaf包对Thymeleaf进行了自动配置，如下图所示：<img src="https://i.loli.net/2018/08/13/5b7122dd0fb63.png" alt="">配置里的所有以spring.thymeleaf为前缀的都是来自<code>ThymeleafProperties</code>这个类。通过查看<code>ThymeleafProperties</code>主要的源代码，可以看出如何设置属性以及默认配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplateLocation = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> String prefix = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"><span class="keyword">private</span> String suffix = <span class="string">".html"</span>;</span><br><span class="line"><span class="keyword">private</span> String mode = <span class="string">"HTML"</span>;</span><br><span class="line"><span class="keyword">private</span> Charset encoding;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cache;</span><br><span class="line"><span class="keyword">private</span> Integer templateResolverOrder;</span><br><span class="line"><span class="keyword">private</span> String[] viewNames;</span><br><span class="line"><span class="keyword">private</span> String[] excludedViewNames;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableSpringElCompiler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThymeleafProperties.Servlet servlet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThymeleafProperties.Reactive reactive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThymeleafProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.encoding = DEFAULT_ENCODING;</span><br><span class="line"><span class="keyword">this</span>.cache = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">this</span>.enabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">this</span>.servlet = <span class="keyword">new</span> ThymeleafProperties.Servlet();</span><br><span class="line"><span class="keyword">this</span>.reactive = <span class="keyword">new</span> ThymeleafProperties.Reactive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>集成时所需的Bean都是通过<code>ThymeleafAutoConfiguration</code>类自动配置的，由于源代码过长这里就不再贴出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/13/5b712bc101a4c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在之前的开发中用到最多的就是JSP，Spring MVC里面也可以很方便的将JSP与一个View关联起来，使用还是非常方便的。但是把一个传统的Spring MVC项目转为一个Spring Boot项目后，却发现JSP和view关联有些麻烦，因为官方不推荐JSP在Spring Boot中使用。&lt;/p&gt;
&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;首先在 &lt;code&gt;pom.xml&lt;/code&gt; 中添加对 &lt;code&gt;thymeleaf&lt;/code&gt; 模板依赖&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里使用上一次新建的工程(&lt;a href=&quot;https://cqjokers.top/note/2018/08/10/ec5b638f.html&quot;&gt;参考地址&lt;/a&gt;)在些基础上加入&lt;code&gt;Thymeleaf&lt;/code&gt;,在templaes目录中建立一个user.html模版，如下图所示：
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
      <category term="thymeleaf" scheme="https://cqjokers.top/tags/thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (四)JdbcTemplate的整合</title>
    <link href="https://cqjokers.top/note/2018/08/10/ec5b638f.html"/>
    <id>https://cqjokers.top/note/2018/08/10/ec5b638f.html</id>
    <published>2018-08-10T08:29:18.000Z</published>
    <updated>2018-08-10T08:35:18.461Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/10/5b6d4cb1ac2b0.jpg" alt=""></p><h1 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h1><p>在<code>pom.xml</code>中添加一些依赖来配置数据源，我们在pom.xml中加入以下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mysql包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring JDBC 的依赖包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9090</span></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/SBL?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">#    type: com.zaxxer.hikari.HikariDataSource</span><br></pre></td></tr></table></figure><p>上面的type是配置连接池的类型，如果没有配置的话默认是使用hikari的，可以通过控制来看，如下面所示：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.s.j.e.a.AnnotationMBeanExporter        : Bean with name <span class="string">'dataSource'</span> has been autodetected <span class="keyword">for</span> JMX exposure</span><br><span class="line">o.s.j.e.a.AnnotationMBeanExporter        : Located MBean <span class="string">'dataSource'</span>: registering with JMX server as MBean [com.zaxxer.hikari:name=dataSource,type=HikariDataSource]</span><br><span class="line">o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: 9090 <span class="params">(http)</span> with context path ''</span></span><br></pre></td></tr></table></figure></p><p>也可以通过源代码来查看，主要代码位于<code>DataSourceAutoConfiguration</code>中的<code>PooledDataSourceConfiguration</code>方法处，如下面所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;DataSourceAutoConfiguration.PooledDataSourceCondition.class&#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(&#123;DataSource.class, XADataSource.class&#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PooledDataSourceConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出SpringBoot默认支持Hikari、Tomcat、Dbcp2、Generic这五种数据源,所以可能通过<code>spring.datasource.type</code>来指定其它种类的连接池。假如这5种都不想用，换用阿里的druid数据源。首先是加入依赖<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.14&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>然后修改配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></p><p>除了上面的配置方式外，还有另外一种方式就是通过代码来完成，不过首先也得添加依赖。代码如下面所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/SBL?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8"</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setMinIdle(<span class="number">60</span>);</span><br><span class="line">dataSource.setMaxActive(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面方法的值都是直接写入的，当然也可以通过<code>Environment</code>来读取配置中的变量的值来填 入推荐使用<code>Environment</code>方式。相对于配置方式更加推荐使用代码来完成，因为在代码中还可以设置数据源其它信息，而配置中则不能。</p><h1 id="数据表创建"><a href="#数据表创建" class="headerlink" title="数据表创建"></a>数据表创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_user`  (</span><br><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(<span class="number">50</span>) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT <span class="string">'用户名'</span>,</span><br><span class="line">  `password` varchar(<span class="number">50</span>) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT <span class="string">'密码'</span>,</span><br><span class="line">  `tel` varchar(<span class="number">19</span>) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT <span class="string">'电话号码'</span>,</span><br><span class="line">  `nickname` varchar(<span class="number">50</span>) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT <span class="string">'昵称'</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span> USING BTREE</span></span><br><span class="line"><span class="function">) ENGINE </span>= InnoDB AUTO_INCREMENT = <span class="number">1</span> CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure><p>这里创建一张简单用户表供后面进行数据的操作。</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>按照平时开发中的套路来，controller中获取参数传给service层中进行业务逻辑处理，然后由dao层负责与数据库交互，所以就有下面的的结构图：<img src="https://i.loli.net/2018/08/10/5b6d3d2086817.png" alt=""></p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>在service类中我们通常通过@service注解来标示这是一个service，由spring在启动时自动扫描进容器中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">UserInfo <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.queryUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserInfo <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">queryUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from t_user where id= ?"</span>;</span><br><span class="line">        UserInfo userInfo = jdbcTemplate.queryForObject(sql,<span class="keyword">new</span> Object[]&#123;id&#125;,<span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(UserInfo.class));</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">queryUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from t_user"</span>;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = jdbcTemplate.query(sql,<span class="keyword">new</span> Object[]&#123;&#125;,<span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(UserInfo.class));</span><br><span class="line">        <span class="keyword">return</span> userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>这里使用<code>RestController</code>注解而没有使用<code>Controller</code>注解，因为这里不需要页面跳转。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        UserInfo userInfo = userService.getUserById(id);</span><br><span class="line">        <span class="keyword">return</span>  userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">getUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = userService.getAllUser();</span><br><span class="line">        <span class="keyword">return</span> userInfoList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试直接用项目里的测试类进行，也可以通过测试工具postman或者浏览器里直接访问来看结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes=SblApplication.class,webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SblApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SblApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询单个</span></span><br><span class="line">        ResponseEntity&lt;UserInfo&gt; responseEntity =  template.getForEntity(<span class="string">"http://localhost:9090/user/&#123;id&#125;"</span>,UserInfo.class,<span class="number">2</span>);</span><br><span class="line">        logger.info(responseEntity.getBody().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        ResponseEntity&lt;List&lt;UserInfo&gt;&gt; responseEntity1 = template.exchange(<span class="string">"http://localhost:9090/users"</span>, HttpMethod.GET, <span class="keyword">null</span>, <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;UserInfo&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.info(responseEntity1.getBody().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top.cqjokers.sbl.SblApplication: UserInfo&#123;id=<span class="number">2</span>, username=<span class="string">'测试'</span>, password=<span class="string">'123'</span>, nickname=<span class="string">'123'</span>&#125;</span><br><span class="line">top.cqjokers.sbl.SblApplication: [UserInfo&#123;id=<span class="number">1</span>, username=<span class="string">'cqjokers'</span>, password=<span class="string">'123'</span>, nickname=<span class="string">'大叔'</span>&#125;, UserInfo&#123;id=<span class="number">2</span>, username=<span class="string">'测试'</span>, password=<span class="string">'123'</span>, nickname=<span class="string">'123'</span>&#125;]</span><br></pre></td></tr></table></figure></p><p>这里直接用的toString方法，所以重写下UserInfo的toString方法即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/10/5b6d4cb1ac2b0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;导入依赖&quot;&gt;&lt;a href=&quot;#导入依赖&quot; class=&quot;headerlink&quot; title=&quot;导入依赖&quot;&gt;&lt;/a&gt;导入依赖&lt;/h1&gt;&lt;p&gt;在&lt;code&gt;pom.xml&lt;/code&gt;中添加一些依赖来配置数据源，我们在pom.xml中加入以下依赖：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--mysql包--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--Spring JDBC 的依赖包--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;2.0.4.RELEASE&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;server:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  port: &lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  datasource:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url: jdbc:mysql:&lt;span class=&quot;comment&quot;&gt;//localhost:3306/SBL?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    password: root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    driver-class-name: com.mysql.jdbc.Driver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#    type: com.zaxxer.hikari.HikariDataSource&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的type是配置连接池的类型，如果没有配置的话默认是使用hikari的，可以通过控制来看，如下面所示：&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (三)静态资源处理</title>
    <link href="https://cqjokers.top/note/2018/08/10/ee362fc5.html"/>
    <id>https://cqjokers.top/note/2018/08/10/ee362fc5.html</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-08-10T08:35:18.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/10/5b6d18f56c5e9.jpg" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平时开发中难免会对静态资源的访问，如js、css、图片等其它资源，在SpringBoot中对静态资源提供了很好的支持，基本上可以直接通过配置就能满足平时开发中的需求，当然对于特殊需求也可以自定义资源映射来满足</p><h1 id="默认静态资源映射"><a href="#默认静态资源映射" class="headerlink" title="默认静态资源映射"></a>默认静态资源映射</h1><p>我们通过启动的时候控制台输出可以发现Spring Boot 默认将 /**映射到所有资源目录，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6cf32ace9a4.png" alt=""><br>那么默认的资源目录有哪些了，我们可以通过在<code>application.properties</code>配置文件中尝试输入static然后IDEA工具会自动显示出与之相关的配置，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6cf44a625a9.png" alt="">这里我们选择第一个，然后按住ctrl点击它则会进入<code>ResourceProperties</code>类，在类的开始处就定义了一个字符串数组来存放默认资源路径，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6cf55d88d61.png" alt="">SpringBoot默认的资源路径有以下几个：</p><blockquote><p>1、classpath:/META-INF/resources/<br>2、classpath:/resources/<br>3、classpath:/static/<br>4、classpath:/public/</p></blockquote><a id="more"></a><p>在访问资源时会按照这个顺序进行搜索直到找到为止。在第一张图片中发现还有一个/webjars/<strong>,那么这个映射的路径又是什么了，首先先找到<code>spring-boot-autoconfigure</code>包中的spring.factories如图所示：<img src="https://i.loli.net/2018/08/10/5b6cfa701e8a9.png" alt="">然后在里面找到<code>WebMvcAutoConfiguration</code>按住ctrl点击进入该类，搜索webjars则会找到它的映射目录，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6cfadd49fde.png" alt="">通过上图可知/webjars/</strong>映射的目录是<code>classpath:/META-INF/resources/webjars/</code>，访问webjars下的资源都会映射到该目录里去。</p><h1 id="自定义静态资源映射"><a href="#自定义静态资源映射" class="headerlink" title="自定义静态资源映射"></a>自定义静态资源映射</h1><p>有时候开发中可能需要自定义静态资源访问路径，那么这里有两种方式来实现：<br>1、修改配置文件中相关配置<br>2、继承<code>WebMvcConfigurationSupport</code>来实现<br>第一种方式：修改application.properties<br>比如说现在想让<code>/assets/**</code>映射到默认资源路径上则只需要在配置中加上<code>spring.mvc.static-path-pattern=/assets/**</code>即可，配置了该项后默认的就不再生效，比如访问/resources/1.jpg这样的将不再会访问到。如果需要修改默认资源路径，则在配置中加上<code>spring.resources.static-locations</code>并将值设置为自己的资源路径，这里可以设置多个以逗号分隔。<br>第二种方式：继承<code>WebMvcConfigurationSupport</code><br>可以写一个类来继承<code>WebMvcConfigurationSupport</code>并得它的<code>addResourceHandlers</code>方法来达到自定义静态资源映射，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6d035fd9dec.png" alt="">在该方法中我添加了多个资源映射，该方式与配置方式的好处在于可以添加多个，而配置方式只能设置一个。现在暂且不看<code>configureViewResolvers</code>方法可以运行起来试试看，结果应该不是预期的那样，会得到一个错误页面，并在控制台中有错误信息。如下图所示：<img src="https://i.loli.net/2018/08/10/5b6d04260dd12.png" alt="">根据错误信息可知是没有找到对应的视图，但是我在application.proerities中进行了视图的相关配置。要想知道错误的原因则需要从入口类中的<code>EnableAutoConfiguration</code>注解中的<code>EnableAutoConfiguration</code>进行分析，在这里大概说下是怎么回事，在启动的时候会根<code>EnableAutoConfiguration</code>注解导入的<code>AutoConfigurationImportSelector</code>类中的<code>getCandidateConfigurations</code>方法去导入<code>spring-boot-autoconfigure</code>jar下面的配置文件META-INF/spring.factories，在这个配置文件中会找到一个WebMvcAutoConfiguration，如下图所示：<img src="https://i.loli.net/2018/08/10/5b6d13d1e0146.png" alt="">进入该类会发现一个<code>ConditionalOnMissingBean</code>注解，它的意思是如果不存在它修饰的类的bean,则再创建这个bean。源码如下图所示：<img src="https://i.loli.net/2018/08/10/5b6d14ca35e9c.png" alt="">由此可得出结论：<br>如果有配置文件继承了DelegatingWebMvcConfiguration，<br>或者WebMvcConfigurationSupport，或者配置文件有@EnableWebMvc，那么 @EnableAutoConfiguration 中的WebMvcAutoConfiguration 将不会被自动配置，而是使用WebMvcConfigurationSupport的配置。所以到这里就基本上明白了上面访问的时候报错的原因了，现在只需要在自定义类中重写<code>configureViewResolvers</code>方法，加上相关设置即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在开发过程中如果使用了类似<code>@EnableWebMvc</code>这样的注解，则<code>@EnableAutoConfiguration</code>中的将不再生效，这就需要在代码中进行相关设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/10/5b6d18f56c5e9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在平时开发中难免会对静态资源的访问，如js、css、图片等其它资源，在SpringBoot中对静态资源提供了很好的支持，基本上可以直接通过配置就能满足平时开发中的需求，当然对于特殊需求也可以自定义资源映射来满足&lt;/p&gt;
&lt;h1 id=&quot;默认静态资源映射&quot;&gt;&lt;a href=&quot;#默认静态资源映射&quot; class=&quot;headerlink&quot; title=&quot;默认静态资源映射&quot;&gt;&lt;/a&gt;默认静态资源映射&lt;/h1&gt;&lt;p&gt;我们通过启动的时候控制台输出可以发现Spring Boot 默认将 /**映射到所有资源目录，如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/10/5b6cf32ace9a4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;那么默认的资源目录有哪些了，我们可以通过在&lt;code&gt;application.properties&lt;/code&gt;配置文件中尝试输入static然后IDEA工具会自动显示出与之相关的配置，如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/10/5b6cf44a625a9.png&quot; alt=&quot;&quot;&gt;这里我们选择第一个，然后按住ctrl点击它则会进入&lt;code&gt;ResourceProperties&lt;/code&gt;类，在类的开始处就定义了一个字符串数组来存放默认资源路径，如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/10/5b6cf55d88d61.png&quot; alt=&quot;&quot;&gt;SpringBoot默认的资源路径有以下几个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、classpath:/META-INF/resources/&lt;br&gt;2、classpath:/resources/&lt;br&gt;3、classpath:/static/&lt;br&gt;4、classpath:/public/&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (二)JSP的支持</title>
    <link href="https://cqjokers.top/note/2018/08/09/c7818a32.html"/>
    <id>https://cqjokers.top/note/2018/08/09/c7818a32.html</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2018-08-09T08:14:08.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/09/5b6bf25825e3d.jpg" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于SpringBoot推荐的视图是Thymeleaf,而在之前我们的开发中使用的是JSP，初次接触当然希望还是能用JSP来作试图，后面再去尝试Thymeleaf,本文内容说的就是如何让SpringBoot web项目支持JSP。</p><h1 id="视图配置"><a href="#视图配置" class="headerlink" title="视图配置"></a>视图配置</h1><p>项目的创建这里就不再展示，可以参考<a href="https://cqjokers.top/note/2018/08/08/170f521.html">工程构建这一篇</a>，在这里我们参照Eclipse的目录风格来，首先是在main包中创建webapp目录，再在webapp中创建WEB-INF文件夹，最后创建一个存放jsp文件的文件夹，这里我使用views这个名字，最终结构如下图所示：<img src="https://i.loli.net/2018/08/09/5b6bad376f1d1.png" alt="">使用过springmvc我们应该知道，在配置中我们需要配置视图解析器的前缀目录与后缀，在这里我们仍然需要进行配置。配置如下图所示：<img src="https://i.loli.net/2018/08/09/5b6bdf10628d5.png" alt="">这里我使用的端口是9090配置文件用的是yml格式，配置好后现在虽然能运行起来但是访问页面只会返回一个错误页面。</p><h1 id="JSP创建"><a href="#JSP创建" class="headerlink" title="JSP创建"></a>JSP创建</h1><p>在view文件夹中新建一个<code>index.jsp</code>文件，如下图所示<a id="more"></a>：<img src="https://i.loli.net/2018/08/09/5b6be4a98ecec.png" alt=""></p><h1 id="控制器创建"><a href="#控制器创建" class="headerlink" title="控制器创建"></a>控制器创建</h1><p>在controller包中创建一个<code>IndexController</code>类，并在首部加上<code>@Controller</code>注解，这里之所以没有使用<code>@RestController</code>注解是因为我们需要在这个类中的index方法跳转到一个页面，@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。在index方法上添加<code>@RequestMapping(value = &quot;/index&quot;)</code>，浏览器通过地址加上该路径则会访问该方法，代码如下图所示：<img src="https://i.loli.net/2018/08/09/5b6be6180f890.png" alt=""></p><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><p>为了能够访问页面我们需要添加jsp、servlet的maven支持，开发中还会用到jstl所以在这里也一并添加进去<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>到此基本上算是完成了，现在启动项目看下是否能够达到预期的效果，结果如下图所示：<img src="https://i.loli.net/2018/08/09/5b6be796c3d36.png" alt="">如果显示下面页面则代表已经成功了。</p><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>虽然说通过IDEA启动能访问，但是这里还有一个问题就是，当你打包成JAR包后运行，则会发现返回的是一个错误页面，造成该错误的原因是，打包时并没有将web资源一起打进去，可以把JAR包解压查看里面的文件。所以打包时需要将jsp文件加入进去，在pom.xml中添加以下配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/webapp&lt;/directory&gt;</span><br><span class="line">&lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**<span class="comment">/**&lt;/include&gt;</span></span><br><span class="line"><span class="comment">&lt;/includes&gt;</span></span><br><span class="line"><span class="comment">&lt;/resource&gt;</span></span><br><span class="line"><span class="comment">&lt;resource&gt;</span></span><br><span class="line"><span class="comment">&lt;directory&gt;src/main/resources&lt;/directory&gt;</span></span><br><span class="line"><span class="comment">&lt;filtering&gt;false&lt;/filtering&gt;</span></span><br><span class="line"><span class="comment">&lt;includes&gt;</span></span><br><span class="line">&lt;include&gt;**/**&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>最关键的一个步骤就是在spring-boot-maven-plugin中一定要加上 <version>1.4.2.RELEASE</version>否则打包出来一样无法访问jsp文件，可以进行尝试换成高于1.4.2版本看下会是怎样的结果，不出意外应该也是返回错误页面</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/09/5b6bf25825e3d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于SpringBoot推荐的视图是Thymeleaf,而在之前我们的开发中使用的是JSP，初次接触当然希望还是能用JSP来作试图，后面再去尝试Thymeleaf,本文内容说的就是如何让SpringBoot web项目支持JSP。&lt;/p&gt;
&lt;h1 id=&quot;视图配置&quot;&gt;&lt;a href=&quot;#视图配置&quot; class=&quot;headerlink&quot; title=&quot;视图配置&quot;&gt;&lt;/a&gt;视图配置&lt;/h1&gt;&lt;p&gt;项目的创建这里就不再展示，可以参考&lt;a href=&quot;https://cqjokers.top/note/2018/08/08/170f521.html&quot;&gt;工程构建这一篇&lt;/a&gt;，在这里我们参照Eclipse的目录风格来，首先是在main包中创建webapp目录，再在webapp中创建WEB-INF文件夹，最后创建一个存放jsp文件的文件夹，这里我使用views这个名字，最终结构如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/09/5b6bad376f1d1.png&quot; alt=&quot;&quot;&gt;使用过springmvc我们应该知道，在配置中我们需要配置视图解析器的前缀目录与后缀，在这里我们仍然需要进行配置。配置如下图所示：&lt;img src=&quot;https://i.loli.net/2018/08/09/5b6bdf10628d5.png&quot; alt=&quot;&quot;&gt;这里我使用的端口是9090配置文件用的是yml格式，配置好后现在虽然能运行起来但是访问页面只会返回一个错误页面。&lt;/p&gt;
&lt;h1 id=&quot;JSP创建&quot;&gt;&lt;a href=&quot;#JSP创建&quot; class=&quot;headerlink&quot; title=&quot;JSP创建&quot;&gt;&lt;/a&gt;JSP创建&lt;/h1&gt;&lt;p&gt;在view文件夹中新建一个&lt;code&gt;index.jsp&lt;/code&gt;文件，如下图所示
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot (一)工程构建</title>
    <link href="https://cqjokers.top/note/2018/08/08/170f521.html"/>
    <id>https://cqjokers.top/note/2018/08/08/170f521.html</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-09T02:12:17.355Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/08/08/5b6abd5c099db.png?300x600" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于之前一直都是用的SSM，未接触过Spring Boot 然而现在很多公司都在用Spring Boot，因为Spring Boot 设计目的是用来简化新Spring应用的初始搭建以及开发过程，使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。所以有了它开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑上面，由于是初次接触所以记录一下学习过程。</p><h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><p>在这里我使用的是IntelliJ IDEA来构建项目，打开工具界面如下图：<img src="https://i.loli.net/2018/08/08/5b6a943d736f5.png" alt="">点击 Create New Project来创建一个SpringBoot应用程序，点击后效果图如下所示：<a id="more"></a><img src="https://i.loli.net/2018/08/08/5b6a94a066098.png" alt="">在左侧我们选择Spring Initializr然后点击Next进入下一个界面，填 入相关信息，如下图所示：<img src="https://i.loli.net/2018/08/08/5b6a95da93a13.png" alt="">填入信息后点击Next按钮进入下一个界面，这个界面上会显示很多项目所需要的依赖，在这里我们勾选上web即可。如下图所示：<img src="https://i.loli.net/2018/08/08/5b6a96b2d1d9b.png" alt="">最后点击Next即可，这样项目就创建成功了</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>我们来看一下IDEA给我们生成的目录结构，如下图所示：<img src="https://i.loli.net/2018/08/08/5b6a97a81dbd2.png" alt=""> </p><blockquote><p>1、/src/main/java/  存放项目所有源代码目录<br>2、/src//main/resources/  存放项目所有资源文件以及配置文件目录,其中static存入静态资源如css、js、img等，templates是存放模版资源<br>3、/src/test/  存放测试代码目录<br>4、pom文件为基本的依赖管理文件</p></blockquote><p><code>SblApplication</code>为程序的入口文件，这个类中使用了一个<code>SpringBootApplication</code>注解,该注解在SpringBoot项目中有且只有这么一个注解存在，它的作用就是声明当前类为SpringBoot的入口类</p><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><p>pom.xml是整个maven的核心配置文件，里面有对项目的描述和项目所需要的依赖。我们在创建好项目后我们最好先设置一下该项目的Maven设置(IDEA对每个项目的maven设置与Eclipse有差别，Eclipse设置一次就行，而IDEA每次新建项目后都需要设置)<img src="https://i.loli.net/2018/08/08/5b6aa068af11f.png" alt="">将Maven目录指向我们安装的Maven位置，选择user setting配置文件后在Eclipse中会自动将本地厂库的路径设置为setting文件中配置的路径，而在IDEA中则不行，需要自己手动设置。这里最好不要用默认配置，默认配置是在C盘中，随着项目的增多依赖的库较多的时候本地厂库占用的空间也会较多，所以最后配置在其它盘中。就算后面重装了系统这些文件依然存在。</p><h1 id="初次运行"><a href="#初次运行" class="headerlink" title="初次运行"></a>初次运行</h1><p>进入<code>SblApplication</code>中右键运行该项目，如何在控制台输出以下信息则代表项目已经运行成功，如下图所示：<img src="https://i.loli.net/2018/08/08/5b6aac7b65e25.png" alt="">这里可能会有些疑问，我们没有配置WEB容器为什么能够运行起来，观看控制台的输出可以看到Starting Servlet Engine:Apache Tomcat/8.5.32说明其实也是通过Tomcat来运行的，只是SpringBoot帮我们省去了这一步的操作，因为SpringBoot内置了Tomcat。现在我们通过浏览器访问看看会得到什么样的结果，结果如下图所示：<img src="https://i.loli.net/2018/08/08/5b6aae48cd6c0.png" alt="">这里得到的只是一个错误页面</p><h1 id="惯例HelloWorld"><a href="#惯例HelloWorld" class="headerlink" title="惯例HelloWorld"></a>惯例HelloWorld</h1><p>在sbl包下面创建一个controller为名字的包用于存放控制器，包创建好后再创建一个<code>IndexController</code>的类，在类上我们使用<code>@RestController</code>注解来声明该类是一个访问控制器，在该类中创建一个index方法，并配置一个<code>@RequestMapping</code>注解来声明它，<code>@RequestMapping</code>中的默认参数写成”/index”,方法体中直接返回”HelloWorld”字符串，这样我们就可以通过<a href="http://localhost:8080/index访问到该方法，代码如下图所示：" target="_blank" rel="noopener">http://localhost:8080/index访问到该方法，代码如下图所示：</a><br><img src="https://i.loli.net/2018/08/08/5b6ab4c318c1d.png" alt="">通过浏览器访问<a href="http://localhost:8080/index会看到页面上输出Hello" target="_blank" rel="noopener">http://localhost:8080/index会看到页面上输出Hello</a> World就说明已经成功了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要通过Spring Boot简单特性来完成了第一个”Hello Word”web应用程序的搭建，从中可以看出Spring Boot在搭建一个项目整合组件方面很成熟，这就有效的提高团队开发效率大减少了开发人员上手周期。由于本人未接触过Spring Boot文章中若有不对的地方还请指出，写文章的目的在于对自己学习的一个记录以及对自己的一个提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/08/08/5b6abd5c099db.png?300x600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于之前一直都是用的SSM，未接触过Spring Boot 然而现在很多公司都在用Spring Boot，因为Spring Boot 设计目的是用来简化新Spring应用的初始搭建以及开发过程，使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。所以有了它开发人员不用再去注重配置文件的繁琐而是把精力放到业务逻辑上面，由于是初次接触所以记录一下学习过程。&lt;/p&gt;
&lt;h1 id=&quot;项目构建&quot;&gt;&lt;a href=&quot;#项目构建&quot; class=&quot;headerlink&quot; title=&quot;项目构建&quot;&gt;&lt;/a&gt;项目构建&lt;/h1&gt;&lt;p&gt;在这里我使用的是IntelliJ IDEA来构建项目，打开工具界面如下图：&lt;img src=&quot;https://i.loli.net/2018/08/08/5b6a943d736f5.png&quot; alt=&quot;&quot;&gt;点击 Create New Project来创建一个SpringBoot应用程序，点击后效果图如下所示：
    
    </summary>
    
      <category term="SpringBoot" scheme="https://cqjokers.top/categories/SpringBoot/"/>
    
    
      <category term="spring boot" scheme="https://cqjokers.top/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>JAVA类加载机制</title>
    <link href="https://cqjokers.top/note/2018/07/30/9fd04b7.html"/>
    <id>https://cqjokers.top/note/2018/07/30/9fd04b7.html</id>
    <published>2018-07-29T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.555Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13023122-65d6e90207ca50b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、卸载7个阶段。类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始,这是为了支持Java语言语言的运行时绑定（也叫动态绑定和晚期绑定）。 </p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段,虚拟机需要完成以下3件事情:</p><ul><li>通过一个类的全限定名来获取此定义类的二进制字节流;</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;</li><li>在内存中生在一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口。<br>一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成(即重写一个类加载器的loadClass()方法)。数组类本身不通过类加载器创建，它是由JVM直接创建的。但数组类和类加载器仍有很紧密的关系，因为数组类的元素类型最终是靠类加载器去创建。<br>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个java.lang.Classo类的对象作为程序访问方法区中的这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未结束，连接阶段就可能开始了。但是夹在加载阶段进行的动作，仍然属于连接阶段的内容。<a id="more"></a><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2>验证是连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。 验证阶段是非常重要的，这个阶段是否严谨，直接决定了JAVA虚拟机是否能承受恶意代码的攻击。验证阶段大致分为4个阶段的校验动作：文件格式验证<br>、元数据验证、字节码验证、符号引用验证。</li><li>文件格式验证：<br>  验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。验证点主要有：是否以魔数(0xCAFEBABE)开关、主/次版本号是否在当前虚拟机处理范围内、常量池的常量中是否有不被支持的常量类型、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量等其它验证点<br>  该阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li><li>元数据验证：<br>  这一阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合JAVA语言规范。验证点包括：这个类是否有父类(Object不算)、这个类父类是否继承了不允许被继承的类(final修饰的类)、这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法、类中的方法/字段是否与父类产生矛盾<br>  这一阶段的主要目的是对类的元数据信息进行语义分校验，保证不存在不符合JAVA语言规范的元数据信息。</li><li>字节码验证：<br>  通过数据流与控制流分析，确定程序语义是合法的、符合逻辑的。这一阶段主要是对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全事件。校验点有：保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体中的类型转换是有效的<br>  如果一个类方法体的字节码没有通过字节验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li><li>符号引用验证:<br>  这一阶段的验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段发生。符号引用验证可以看做是对类自身以外(常量池中的各种引用)的信息进行匹配性校验，通常需要校验下我内容：符号引用中通过字符串描述的全限定名是否能找到对应的类、在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段、符号引用中的类、字段、方法的访问性是否可被当前类访问等<br>  符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如IllegalAccessError、NoSuchfiledError、NoSuchMethodError等。<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量), 而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配置到java堆中。<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</li><li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用: 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量。<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的JAVA程序代码。<br>参考：深入理解JAVA虚拟机第二版</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13023122-65d6e90207ca50b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、卸载7个阶段。类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始,这是为了支持Java语言语言的运行时绑定（也叫动态绑定和晚期绑定）。 &lt;/p&gt;
&lt;h2 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;headerlink&quot; title=&quot;加载&quot;&gt;&lt;/a&gt;加载&lt;/h2&gt;&lt;p&gt;在加载阶段,虚拟机需要完成以下3件事情:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取此定义类的二进制字节流;&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构;&lt;/li&gt;
&lt;li&gt;在内存中生在一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口。&lt;br&gt;一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成(即重写一个类加载器的loadClass()方法)。数组类本身不通过类加载器创建，它是由JVM直接创建的。但数组类和类加载器仍有很紧密的关系，因为数组类的元素类型最终是靠类加载器去创建。&lt;br&gt;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个java.lang.Classo类的对象作为程序访问方法区中的这些类型数据的外部接口。&lt;br&gt;加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未结束，连接阶段就可能开始了。但是夹在加载阶段进行的动作，仍然属于连接阶段的内容。
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA垃圾回收机制</title>
    <link href="https://cqjokers.top/note/2018/07/26/40a57016.html"/>
    <id>https://cqjokers.top/note/2018/07/26/40a57016.html</id>
    <published>2018-07-25T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.554Z</updated>
    
    <content type="html"><![CDATA[<p>围绕三个点进行说明：</p><ul><li>哪些对象需要回收</li><li>什么时候回收</li><li>怎么回收<h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2>要想知道哪些对象需要回收，就得知道哪些对象还是处于存活状态，java中有两算法来判断对象是否还处于存活状态<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3>在堆中每个对象实例都有一个引用计数，当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1，当这个对象被赋值给其它变量时则计数加1，当那个变量超过了生命周期或者被设置为一个新值时则计数减1，当计数为0时则认为该对象死亡可以回收了。</li></ul><p>虽然这种算法简单效率高，但是在循环引用的时候会出现无法回收的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从一个节点GC ROOT开始，录找对应的引用节点，找到后继续去寻找它的引用节点，直到寻找完毕，可以把这一寻找过程理解为一个串。当一个对象通过这个串无法到达GC Root时则可以确认该对象已死亡可以被回收。<br><img src="https://upload-images.jianshu.io/upload_images/13023122-a872b4a45336e57f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>通过上图可以看出object 5,6,7是无法到达GC Root的所以他们是可以被回收的对象<br><a id="more"></a><br>可作为GC Roots的对象包括下面几种：</p><blockquote><ul><li>虚拟机栈中所引用的对象;</li><li>方法区中类静态属性引用的对象；</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ul></blockquote><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h2><p>一个对象实例化时会先去看Eden有没有足够的空间，如果有则不进行垃圾回收 ,对象直接在Eden中，若Eden内存已满,会进行一次垃圾回收清除非存活对象，然后将Eden中存活的对象放入Survivor区，最后整理Survivor的两个区。</p><p>如果Eden与Survivor的两个区都满了，则查看老年代区是否已满，若没满则将部分存活区（Survivor）的活跃对象存入老年代，然后将Eden的活跃对象放入存活区（Survivor）。</p><p>如果老年代内存不足则进行一次full gc，之后老年代会再进行判断 内存是否足够,如果足够同上，否则会抛出OutOfMemoryError。</p><h2 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>从GC Root开始扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，然后进行回收。<img src="https://upload-images.jianshu.io/upload_images/13023122-bd10bd43dc8a958f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收前"><img src="https://upload-images.jianshu.io/upload_images/13023122-0abd9c1d6dcc947d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收后">从上面的图中可以看出，回收后内存空间不是连续的，这就导致产生了很多碎片，如果下一次申请的空间较大时无法找到足够的连续内存所以就得提前触发一次垃圾收集。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法是将可用的内存分为两块区域，每次只用其中的一块，当发生垃圾回收时，会将存活的对象复制到另一块未使用的区域，然后对之前的区域进行回收。<img src="https://upload-images.jianshu.io/upload_images/13023122-5d81e849eb1fcc29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制算法"></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。另一个是老年代存放的都是不容易被回收的对象，再加上内存空间的限制所以一般是不会采用复制算法。老年代采用的与标记-清除算法类似的标记整理算法。</p><p>标记整理算法在对对象进行标记时与标记清除算法一样，区别在于它是让所有存活对象都移动到一端，然后直接清理掉边界以外的内存。<img src="https://upload-images.jianshu.io/upload_images/13023122-bd10bd43dc8a958f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收前"><img src="https://upload-images.jianshu.io/upload_images/13023122-2bcacedb83deaa6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回收后"></p><h3 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h3><ul><li>新生代：分为三个区，Eden和两个Survivor区，整个流程是，Eden满了会向将Eden中的存活对象放入Survivor0中，Survivor0满了则将Eden与Survivor0中存活的对象放入Survivor1中，清空eden和这个survivor0区，将Survivor0与Survivor1进行交换，重复这样的流程。当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC。</li><li>老年代：老年代中存放的都是一些生命周期较长的对象。当老年代满时会触发Full GC<br>在jdk8之前还有持久代，从jdk8开始已经将持久代（PermGen Space） 干掉了，取而代之的元空间（Metaspace）。Metaspace占用的是本地内存，不再占用虚拟机内存。<br>在新生代中采用的是复制算法，简单高效。在老年代中则是采用标识-清除或者是标记-整理算法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;围绕三个点进行说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些对象需要回收&lt;/li&gt;
&lt;li&gt;什么时候回收&lt;/li&gt;
&lt;li&gt;怎么回收&lt;h2 id=&quot;哪些对象需要回收&quot;&gt;&lt;a href=&quot;#哪些对象需要回收&quot; class=&quot;headerlink&quot; title=&quot;哪些对象需要回收&quot;&gt;&lt;/a&gt;哪些对象需要回收&lt;/h2&gt;要想知道哪些对象需要回收，就得知道哪些对象还是处于存活状态，java中有两算法来判断对象是否还处于存活状态&lt;h3 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h3&gt;在堆中每个对象实例都有一个引用计数，当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1，当这个对象被赋值给其它变量时则计数加1，当那个变量超过了生命周期或者被设置为一个新值时则计数减1，当计数为0时则认为该对象死亡可以回收了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这种算法简单效率高，但是在循环引用的时候会出现无法回收的问题。&lt;/p&gt;
&lt;h3 id=&quot;可达性分析算法&quot;&gt;&lt;a href=&quot;#可达性分析算法&quot; class=&quot;headerlink&quot; title=&quot;可达性分析算法&quot;&gt;&lt;/a&gt;可达性分析算法&lt;/h3&gt;&lt;p&gt;从一个节点GC ROOT开始，录找对应的引用节点，找到后继续去寻找它的引用节点，直到寻找完毕，可以把这一寻找过程理解为一个串。当一个对象通过这个串无法到达GC Root时则可以确认该对象已死亡可以被回收。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13023122-a872b4a45336e57f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过上图可以看出object 5,6,7是无法到达GC Root的所以他们是可以被回收的对象&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA内存划分</title>
    <link href="https://cqjokers.top/note/2018/07/25/a0da5680.html"/>
    <id>https://cqjokers.top/note/2018/07/25/a0da5680.html</id>
    <published>2018-07-24T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.559Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对数据进行了不同空间的划分，每一片区域都有特定的处理数据方式和内存管理方式。<br>具体划分为如下5个内存空间：</p><ul><li>程序计数器</li><li>java栈(虚拟机栈)</li><li>本地方法栈</li><li>堆</li><li>方法区(jdk8换用metaSpace)<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2>程序计数器是线程独有的，每个线程都有一个属于自己的程序计数器，它的作用是指向下一条指令的地址，在线程创建的时候就创建它。正是因为有了它，在多线程情况下才能知道每条线程上次执行的位置，当切换回来的时候才能明确该从哪里开始执行。<h2 id="java栈（虚拟机栈）"><a href="#java栈（虚拟机栈）" class="headerlink" title="java栈（虚拟机栈）"></a>java栈（虚拟机栈）</h2>虚拟机栈由一系列栈帧组成，每个方法被调用的时候都会创建一个栈帧压入虚拟机栈中，每个栈帧用于存储局部变量表，操作栈，常量池指针，方法出口等信息，当方法执行完毕之后，便会将栈帧出栈。在多线程情况下由于每个线程正在执行的方法很有可能不相同，所以JAVA栈是线程独有的，每个线程都会有一个自己的Java栈，互不干扰。<a id="more"></a><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2>本地方法栈与java虚拟机栈原理非常相似，区别是：java虚拟机栈是为虚拟机执行java方法服务的而本地方法栈则是为虚拟机执行本地方法（Native Method）服务。<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2>堆是这几块内存区域中最大的一块用来存储对象本身和数组，在虚拟机启动的时候堆内存也就被创建了，这块内存被所有线程共享，在虚拟机运行期间的所有线程创建的对象的实例都被存储在堆内存中，由于对象都存在该堆上所以它也是垃圾收集器管理的主要区域。<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2>从jdk8开始方法区用Meta Space代替并且metaSpace不再放在运行时数据区域而是放在本地的内存中。它和堆一样是所有线程共享的。存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对数据进行了不同空间的划分，每一片区域都有特定的处理数据方式和内存管理方式。&lt;br&gt;具体划分为如下5个内存空间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;java栈(虚拟机栈)&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;方法区(jdk8换用metaSpace)&lt;h2 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h2&gt;程序计数器是线程独有的，每个线程都有一个属于自己的程序计数器，它的作用是指向下一条指令的地址，在线程创建的时候就创建它。正是因为有了它，在多线程情况下才能知道每条线程上次执行的位置，当切换回来的时候才能明确该从哪里开始执行。&lt;h2 id=&quot;java栈（虚拟机栈）&quot;&gt;&lt;a href=&quot;#java栈（虚拟机栈）&quot; class=&quot;headerlink&quot; title=&quot;java栈（虚拟机栈）&quot;&gt;&lt;/a&gt;java栈（虚拟机栈）&lt;/h2&gt;虚拟机栈由一系列栈帧组成，每个方法被调用的时候都会创建一个栈帧压入虚拟机栈中，每个栈帧用于存储局部变量表，操作栈，常量池指针，方法出口等信息，当方法执行完毕之后，便会将栈帧出栈。在多线程情况下由于每个线程正在执行的方法很有可能不相同，所以JAVA栈是线程独有的，每个线程都会有一个自己的Java栈，互不干扰。
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="memory" scheme="https://cqjokers.top/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://cqjokers.top/note/2018/07/24/111e02e0.html"/>
    <id>https://cqjokers.top/note/2018/07/24/111e02e0.html</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.557Z</updated>
    
    <content type="html"><![CDATA[<p>  一个变量被volatile修饰之后，则具备了两层含义：</p><ul><li>可见性</li><li>禁止指令重排序（保证有序性）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                doSomeThing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;上面例子是经常用一个标识来控制线程的结束，理想状态下当另一个线程调用stop方法后则会立即停止，但这毕竟只是我们的假设，上面的代码很有可能会出现一个死循环，当另一个线程调用stop方法后将flag的值设置为true后但并没有去更新主内存中的数据此时就会出现死循环，加上volatile后则会解决上面的问题。因为使用volatile关键字后会强制将修改的值立即写入主存，并让其它线程中的该变量的值失效，当其它线程需要此变量值时由于自己工作内中的已经失效了所以会从主内存中去获得所以得到的就是最新值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;    （<span class="number">1</span>）</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     （<span class="number">2</span>）</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;   （<span class="number">3</span>）</span><br><span class="line">c = <span class="number">3</span>;   （<span class="number">4</span>）</span><br><span class="line">d = <span class="number">4</span>;    （<span class="number">5</span>）</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>&emsp;&emsp;上面例子中由于flag使用了volatile修饰，所以它不会先于1，2执行也不会后于4，5执行，并且1，2执行的结果是对3，4，5可见的，但是并没有保证1，2和4，5的执行顺序。</p><p>volatile关键字禁止指令重排序有两层意思：<br>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作肯定全部已经完成，且后面的操作肯定还没有开始，前面的执行结果是对后面的操作可见的<br>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p><strong>volatile不能保证操作的原子性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                       num++;</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;.start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//等待计算线程执行完</span></span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4351</span>  <span class="number">3786</span>  <span class="number">4518</span>  <span class="number">3123</span>  <span class="number">3275</span></span><br></pre></td></tr></table></figure></p><p>对上面代码执行了5次但结果都不是预期的5000，由此可以看出虽然num使用了volatile来修饰但在对其进行自增时并不是原子操作。由于自增操作是分为3步完成，在多线程情况下，假如有一个线程将num读取到了自己的本地内存中且是一个很小的值，此时其他线程很有可能已经将num增大了很多，这个线程依然对num进行自加，然后重新写到主存中，这样就导致了num的结果与预期的不符合。要解决上面的问题只需将num类型替换成<code>AtomicInteger</code>就能解决问题<br><strong>volatile 的应用</strong></p><ul><li><p>双重检查锁的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制停止线程的标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                doSomeThing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  一个变量被volatile修饰之后，则具备了两层含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;li&gt;禁止指令重排序（保证有序性）&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; flag = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!flag) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                doSomeThing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;上面例子是经常用一个标识来控制线程的结束，理想状态下当另一个线程调用stop方法后则会立即停止，但这毕竟只是我们的假设，上面的代码很有可能会出现一个死循环，当另一个线程调用stop方法后将flag的值设置为true后但并没有去更新主内存中的数据此时就会出现死循环，加上volatile后则会解决上面的问题。因为使用volatile关键字后会强制将修改的值立即写入主存，并让其它线程中的该变量的值失效，当其它线程需要此变量值时由于自己工作内中的已经失效了所以会从主内存中去获得所以得到的就是最新值。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;    （&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;     （&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; flag = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;   （&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;   （&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;    （&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="volatile" scheme="https://cqjokers.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程中的三个概念</title>
    <link href="https://cqjokers.top/note/2018/07/20/6208b7fd.html"/>
    <id>https://cqjokers.top/note/2018/07/20/6208b7fd.html</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><hr><p>原子性就是对数据的操作是独立的不能被分成几个步骤完成也就是不能进行分割，当前操作要么全部执行并且执行的过程不会被任何因素打断，要么就全部都不执行。最典型的例子就是平时经常用的<code>i++</code>操作，其实这一操作是分为三个步骤完成的：<br>1、 读取整数 i 的值；<br>2、 对 i 进行加一操作；<br>3、 将结果写回内存<br>如果这三步骤操作在单线程中执行是完全没有问题的，但是如果在多线程执行则会遇见意想不到的结果，为了保证是原子操作我们可以使用同步技术（sychronized）和加锁机制（lock )来让它变成一个原子操作。还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。<br><a id="more"></a></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><hr><p>由<a href="https://cqjokers.top/2018/07/19/java/JMM/">JAVA内存模型</a>我们知道，所有数据都是先从主内存中加载到工作内存中，对数据进行修改后是先更新工作内存然后才是更新到主内存中，假如在一个线程修改数据后还未更新到主内存中时，而另外一个线程此时去加载了该数据那么此时得到的就是之前的旧数据。<br>　　对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去主内存中读取新值。相返未使用volatile来修饰的变量则不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主内存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　如果想要普通变量也能保证可见性可以通过synchronized和Lock来保证，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><hr><p>有序性：即程序执行的顺序按照代码的先后顺序执行。看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">a = a - <span class="number">2</span>;</span><br><span class="line">b = a * b;</span><br></pre></td></tr></table></figure></p><p>按照正常逻辑执行的顺序是：1&gt;2&gt;3&gt;4,但是由于处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的，所以上面的执行顺序很有可能是：2&gt;1&gt;3&gt;4,由于处理器在进行重排序时是会考虑指令之间的数据依赖性，如果后面的操作会依赖前面操作的结果，那么就会先执行前面的操作。虽然重排序在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。</p><p>Java 中可以使用 volatile 来保证顺序性，synchronize 和 lock 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。</p><p>除了通过 volatile 关键字显式的保证顺序之外， JVM 还通过 happen-before 原则来隐式的保证顺序性。happens-before原则规则如下：参考-&gt;<a href="http://cmsblogs.com/?p=2102" target="_blank" rel="noopener">死磕Java并发</a></p><blockquote><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子性&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;原子性就是对数据的操作是独立的不能被分成几个步骤完成也就是不能进行分割，当前操作要么全部执行并且执行的过程不会被任何因素打断，要么就全部都不执行。最典型的例子就是平时经常用的&lt;code&gt;i++&lt;/code&gt;操作，其实这一操作是分为三个步骤完成的：&lt;br&gt;1、 读取整数 i 的值；&lt;br&gt;2、 对 i 进行加一操作；&lt;br&gt;3、 将结果写回内存&lt;br&gt;如果这三步骤操作在单线程中执行是完全没有问题的，但是如果在多线程执行则会遇见意想不到的结果，为了保证是原子操作我们可以使用同步技术（sychronized）和加锁机制（lock )来让它变成一个原子操作。还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="thread" scheme="https://cqjokers.top/tags/thread/"/>
    
      <category term="volatile" scheme="https://cqjokers.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>JAVA内存模型的理解</title>
    <link href="https://cqjokers.top/note/2018/07/19/57fe836e.html"/>
    <id>https://cqjokers.top/note/2018/07/19/57fe836e.html</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.550Z</updated>
    
    <content type="html"><![CDATA[<p>我们买电脑时一般会看电脑参数，在这些参数上会有一个高速缓存，这项参数是用来干什么的了。由于电脑CPU执行速度非常快，而执行程序时会从内存读取数据和向内存写入数据这样的一个过程跟CPU执行指令的速度是没法比的，所以对数据的操作都要通过和内存的交互来进行那么就会大大降低指令执行的速度。因此就产生了上面所说的高速缓存。引入了高速缓存虽然在速度上面已经解决了处理器与内存交互的问题，但是又引发了新的问题缓存一致性，为了解决这一问题从而就产生了一些保障数据一致性的协议，它们的核心的思想是：进行写数据时，发现操作的变量是共享变量（其他CPU中也存在该变量的副本），则会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，那么它则会从内存重新读取。<img src="https://upload-images.jianshu.io/upload_images/13023122-755bb213a713906f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><ul><li>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的所以不会被共享。为了获得较高的执行效能，Java内存模型并没有限制使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</li><li>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。<img src="https://upload-images.jianshu.io/upload_images/13023122-93430a960f4c652d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>内存间交互操作<img src="https://upload-images.jianshu.io/upload_images/13023122-cd5613a28e48a513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><blockquote><p>1、 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。<br>2、 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br>3、 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。<br>5、 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。<br>6、 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br>7、store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。<br>8、write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p></blockquote><p>Java内存模型还规定了在执行上述八种基本操作时，还必须满足以下规则：</p><blockquote><p>1、不允许read和load、store和write操作之一单独出现<br>2、不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。<br>3、 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。<br>4、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。<br>5、一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现<br>6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值<br>7、如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>8、对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</p></blockquote><p>参考：<br><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们买电脑时一般会看电脑参数，在这些参数上会有一个高速缓存，这项参数是用来干什么的了。由于电脑CPU执行速度非常快，而执行程序时会从内存读取数据和向内存写入数据这样的一个过程跟CPU执行指令的速度是没法比的，所以对数据的操作都要通过和内存的交互来进行那么就会大大降低指令执行的速度。因此就产生了上面所说的高速缓存。引入了高速缓存虽然在速度上面已经解决了处理器与内存交互的问题，但是又引发了新的问题缓存一致性，为了解决这一问题从而就产生了一些保障数据一致性的协议，它们的核心的思想是：进行写数据时，发现操作的变量是共享变量（其他CPU中也存在该变量的副本），则会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，那么它则会从内存重新读取。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13023122-755bb213a713906f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="JMM" scheme="https://cqjokers.top/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>一致性Hash分析</title>
    <link href="https://cqjokers.top/note/2018/07/18/170f63c6.html"/>
    <id>https://cqjokers.top/note/2018/07/18/170f63c6.html</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>在开发中经常会用到缓存来减轻数据库的压力，比较常见的就是使用redis，但当数据达到一定量时一台缓存服务器已经无法满足现在的需求，所以需要进行分布存储，假设现在有3台缓存服务器，那么该如何将数据均匀的分布到这3台服务器上了。</p><h2 id="取模运算方式"><a href="#取模运算方式" class="headerlink" title="取模运算方式"></a>取模运算方式</h2><p>将传入的Key按照<code>index = hash(key) % len</code>方式计算出需要存放的服务器节点，其中len是服务器数量，通过取模运算就能将数据均匀的分布到不同的服务器上。但这种方式有缺陷，如果某一天老板说再加一台服务器，此时服务器数就变成了4，那么通过上面方式来获取数据很有可能不会命中，因为重新计算了key，换句话说当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时则会向后端服务器请求数据。同理，假设缓存服务器中突然有一台务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，如果想要访问数据，这条数据的缓存位置必定会发生改变，之前缓存的数据也失去了缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时后端服务器将会承受巨大的压力，整个系统很有可能被压垮。<br><a id="more"></a></p><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><p>一致 Hash 算法是将所有的哈希值构成了一个环，其范围在 <code>0 ~ 2^32-1</code>，就像吃的饼子一样，饼子我们可以理解为是由0~60个点组成的圆，那么在这里我们可以理解为由<code>0~2^32-1</code>个点组成的圆，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-5d57d235a45ff089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后通过hash计算将各个节点分配到这个环上，hash计算时可以通过服务器IP+服务器名称等作为唯一key来进行hash(key)计算，假如分配后的图如下：<img src="https://upload-images.jianshu.io/upload_images/13023122-901a27aa013d535d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>假如现在我们需要进行数据缓存，那么我们使用hash(key)方式将key映射到环上，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-7f5413e714c3c0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>现在已经把服务器与数据都映射到这个环上了，但是数据k1会存入哪一台服务器了，这里的数据k1将会存储在s2服务器上，因为从数据在环上的的位置开始顺时针方向找到的第一个服务器就是s2,所以上图中的数据k1会缓存到s2服务器上，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-89e79acab91e7a88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>假如现在我们有一台服务器s1宕机了，那么此时受影响的其实只有k3数据它将会重新映射到S2服务器上，k1,k2其实是没有发生变化的，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-b296891ea3c18d8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>假如现在我们需要在之前3台服务器的基础上再加一台服务器s4，恰好映射在s2与s3之间，那么此时受影响的只有k2，而k1与k3没有发生变化，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-49aa1433cecc9df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="环的偏斜"><a href="#环的偏斜" class="headerlink" title="环的偏斜"></a>环的偏斜</h2><p>在上面的图中我们都是以最好的情况来分析的，想像的是服务器是均匀的分布到这个环上面，然后实际开发中，其实并不一定是均匀分布的，会出现映射的节点偏向某一个方向的情况，这种情况很容易造成数据分布不均匀，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-e15db68df38ab7f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">如上图所示，数据分布在S1服务器上的最多</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>为了应对环的偏斜我们可以添加虚拟节点来弥补，虚拟节点其实就是实际服务器节点的复制品，一个实际节点可以对应多个虚拟节点，我们在生成虚拟节点时，可以在实际服务器IP地址后面加上序号号通过hash计算来生成，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-6080e76a2fdc81d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图中s11,s21,s31就是生成的虚拟节点，这样缓存的分布就均匀得多了，还可以添加更多的虚拟节点来解决环的偏斜，虚拟节点越多缓存分布越均匀。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在进行分布式存储开发中，最好使用一致性Hash来均匀的存放数据</li><li>当服务器较少时，可以添加虚拟节点来解决环的偏斜，从而使得数据均匀的分布到服务器上。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;场景描述&quot;&gt;&lt;/a&gt;场景描述&lt;/h2&gt;&lt;p&gt;在开发中经常会用到缓存来减轻数据库的压力，比较常见的就是使用redis，但当数据达到一定量时一台缓存服务器已经无法满足现在的需求，所以需要进行分布存储，假设现在有3台缓存服务器，那么该如何将数据均匀的分布到这3台服务器上了。&lt;/p&gt;
&lt;h2 id=&quot;取模运算方式&quot;&gt;&lt;a href=&quot;#取模运算方式&quot; class=&quot;headerlink&quot; title=&quot;取模运算方式&quot;&gt;&lt;/a&gt;取模运算方式&lt;/h2&gt;&lt;p&gt;将传入的Key按照&lt;code&gt;index = hash(key) % len&lt;/code&gt;方式计算出需要存放的服务器节点，其中len是服务器数量，通过取模运算就能将数据均匀的分布到不同的服务器上。但这种方式有缺陷，如果某一天老板说再加一台服务器，此时服务器数就变成了4，那么通过上面方式来获取数据很有可能不会命中，因为重新计算了key，换句话说当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时则会向后端服务器请求数据。同理，假设缓存服务器中突然有一台务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，如果想要访问数据，这条数据的缓存位置必定会发生改变，之前缓存的数据也失去了缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时后端服务器将会承受巨大的压力，整个系统很有可能被压垮。&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://cqjokers.top/categories/algorithm/"/>
    
    
      <category term="hash" scheme="https://cqjokers.top/tags/hash/"/>
    
      <category term="algorithm" scheme="https://cqjokers.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LruCache的简单实现</title>
    <link href="https://cqjokers.top/note/2018/07/17/40b4c498.html"/>
    <id>https://cqjokers.top/note/2018/07/17/40b4c498.html</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2018-07-31T01:15:51.556Z</updated>
    
    <content type="html"><![CDATA[<p>由于前面分析过<a href="https://cqjokers.top/2018/07/12/java/LinkedHashMap/">LinkedHashMap</a>，知道其内部运用了一个双向链表结构来存储数据，所以能够保证数据的有序性，并且源代码里预留了三个方法，我们可以基于它们来实现一个LRU缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//最大缓存数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"><span class="comment">//负载因</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUHashMap</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(maxCapacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size() &gt; maxCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于<code>LinkedHashMap</code>是线程不安全的，所以要想在多线程环境使用可以使用 Collections.synchronizedMap()方法实现线程安全操作<br><a id="more"></a></p><ul><li>自己实现一个LRU缓存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//缓存最大数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCacheSize;</span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Node&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;K, Node&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> maxCacheSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxCacheSize = maxCacheSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cacheMap.containsKey(key)) &#123;</span><br><span class="line">Node node = cacheMap.get(key);</span><br><span class="line">removeNode(node);</span><br><span class="line">addNode(node);</span><br><span class="line"><span class="keyword">return</span> (V) node.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否已经存在</span></span><br><span class="line"><span class="keyword">if</span>(cacheMap.containsKey(key)) &#123;</span><br><span class="line"><span class="comment">//移动到首部</span></span><br><span class="line">Node node = cacheMap.get(key);</span><br><span class="line">removeNode(node);</span><br><span class="line">addNode(node);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//添加节点到首部</span></span><br><span class="line">Node&lt;K, V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">cacheMap.put(key, node);</span><br><span class="line">addNode(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cacheMap.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cacheMap.size() &gt; maxCacheSize) &#123;</span><br><span class="line">cacheMap.remove(tail.key);</span><br><span class="line"><span class="comment">//删除尾节点</span></span><br><span class="line">removeNode(tail);</span><br><span class="line">&#125;</span><br><span class="line">node.before = <span class="keyword">null</span>;</span><br><span class="line">Node h = head;</span><br><span class="line">head = node;</span><br><span class="line"><span class="keyword">if</span>(h == <span class="keyword">null</span>)</span><br><span class="line">tail = node;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">node.after = h;</span><br><span class="line">h.before = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node.after == <span class="keyword">null</span>)</span><br><span class="line">tail = node.before;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">node.after.before = node.before;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node.before == <span class="keyword">null</span>) </span><br><span class="line">head = node.after;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">node.before.after = node.after;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder() ;</span><br><span class="line">        Node&lt;K,V&gt; node = tail ;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(node.key).append(<span class="string">":"</span>)</span><br><span class="line">                    .append(node.value)</span><br><span class="line">                    .append(<span class="string">"--&gt;"</span>) ;</span><br><span class="line">            node = node.before ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">K key;</span><br><span class="line"></span><br><span class="line">V value;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; before,after;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试效果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> LRUCache&lt;Integer, Integer&gt;(<span class="number">3</span>);</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(cache);</span><br><span class="line">    </span><br><span class="line">    cache.get(<span class="number">3</span>);</span><br><span class="line">    cache.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(cache);</span><br><span class="line"></span><br><span class="line">    cache.put(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">    System.out.println(cache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>:<span class="number">2</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">4</span>:<span class="number">4</span>--&gt;</span><br><span class="line"><span class="number">4</span>:<span class="number">4</span>--&gt;<span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">5</span>:<span class="number">5</span>--&gt;</span><br><span class="line"><span class="number">3</span>:<span class="number">3</span>--&gt;<span class="number">5</span>:<span class="number">5</span>--&gt;<span class="number">6</span>:<span class="number">6</span>--&gt;</span><br></pre></td></tr></table></figure></p><ul><li>内部使用的是一个HashMap存入数据，不过值是一个Node节点</li><li>使用了一个双向链表将各数据关联起来</li><li>由于存入的值是进行转换后的Node节点，所以在查询的时候，相比遍历整个链表效率要好一点</li><li>由于内部使用的是HashMap所以所有操作都是线程不安全的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于前面分析过&lt;a href=&quot;https://cqjokers.top/2018/07/12/java/LinkedHashMap/&quot;&gt;LinkedHashMap&lt;/a&gt;，知道其内部运用了一个双向链表结构来存储数据，所以能够保证数据的有序性，并且源代码里预留了三个方法，我们可以基于它们来实现一个LRU缓存。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LRUHashMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//最大缓存数目&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxCapacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//负载因&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = &lt;span class=&quot;number&quot;&gt;0.75f&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LRUHashMap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(maxCapacity, DEFAULT_LOAD_FACTOR, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxCapacity = maxCapacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map.Entry&amp;lt;K, V&amp;gt; eldest)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size() &amp;gt; maxCapacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;LinkedHashMap&lt;/code&gt;是线程不安全的，所以要想在多线程环境使用可以使用 Collections.synchronizedMap()方法实现线程安全操作&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="https://cqjokers.top/categories/algorithm/"/>
    
    
      <category term="cache" scheme="https://cqjokers.top/tags/cache/"/>
    
      <category term="LRU" scheme="https://cqjokers.top/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>HashSet原理分析</title>
    <link href="https://cqjokers.top/note/2018/07/15/e40c8608.html"/>
    <id>https://cqjokers.top/note/2018/07/15/e40c8608.html</id>
    <published>2018-07-15T06:59:20.000Z</published>
    <updated>2018-07-31T01:15:51.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashSet实现了Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；它并不保证随着时间的推移，秩序将保持不变。此类允许使用null元素,是一个不允许存储重复元素的集合</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li>map:用于存放数据</li><li>PRESENT: 所有存入的map数据的value值<a id="more"></a><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">     addAll(c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">     map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过构造器可以发现使用的是HashMap来初始化map，但其中有一个包访问级别的构造器，使用的是<code>LinkedHashMap</code>，其主要是对LinkedHashSet的支持。</p><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过add方法可以发现，存入的数据其实是作为了map的键，而真正的值是<code>PRESENT</code>,所以这就保证了存入的数据是没有重复的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>由于HashSet是借助于HashMap来实现的，所以HashMap会出现的问题,HashSet一样会出现</li><li>在用HashSet保存对象的时候，一定要正确的重写其equals和hashCode方法，以保证放入的对象的唯一性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;HashSet实现了Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；它并不保证随着时间的推移，秩序将保持不变。此类允许使用null元素,是一个不允许存储重复元素的集合&lt;/p&gt;
&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; HashMap&amp;lt;E,Object&amp;gt; map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Object PRESENT = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;map:用于存放数据&lt;/li&gt;
&lt;li&gt;PRESENT: 所有存入的map数据的value值
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="set" scheme="https://cqjokers.top/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>Timer底层分析</title>
    <link href="https://cqjokers.top/note/2018/07/14/fa474e95.html"/>
    <id>https://cqjokers.top/note/2018/07/14/fa474e95.html</id>
    <published>2018-07-14T14:24:08.000Z</published>
    <updated>2018-07-31T01:15:51.565Z</updated>
    
    <content type="html"><![CDATA[<p>Timer是jdk1.3中自带的一种线程调度任务的工具。可以执行一个只调度一次的任务也可以重复调度一个一定间隔时间的任务。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line"><span class="comment">//定时调用任务的线程类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object threadReaper = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//用于生成调度线程的名字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger nextSerialNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(<span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.setDaemon(isDaemon);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们实例化一个Timer类的时候会为线程设置一个名字并启动此线程然后一直处于等待状态直到到队列中加入任务<br><a id="more"></a></p><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定延迟后执行指定的任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在指定时间执行任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date time)</span></span></span><br><span class="line"><span class="function"><span class="comment">//任务从指定的延迟后开始进行重复的固定延迟执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span></span></span><br><span class="line"><span class="function"><span class="comment">//任务在指定的时间开始进行重复的固定延迟执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span></span></span><br><span class="line"><span class="function"><span class="comment">//任务在指定的延迟后开始进行重复的固定速率执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span></span></span><br><span class="line"><span class="function"><span class="comment">//任务在指定的时间开始进行重复的固定速率执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, Date firstTime,<span class="keyword">long</span> period)</span></span></span><br></pre></td></tr></table></figure><p>schedule的重复执行与scheduleAtFixedRate的区别在于任务执行起始的时间基准点不一样，schedule下一次执行时间相对于上一次任务实际执行完成的时间点 ，而scheduleAtFixedRate下一次执行时间相对于上一次开始的 时间点 ，因此执行时间不会延后</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Task already scheduled or cancelled"</span>);</span><br><span class="line">                task.nextExecutionTime = time;</span><br><span class="line">                task.period = period;</span><br><span class="line">                task.state = TimerTask.SCHEDULED;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(task);</span><br><span class="line">            <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">                queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键方法里最终都会调用<code>sched</code>方法，该方法主要是设置任务的开始执行时间，周期与状态，将任务加入到队列中，如果加入的任务与队列中的第一个相等则唤醒线程去执行。</p><h2 id="TimerThread类"><a href="#TimerThread类" class="headerlink" title="TimerThread类"></a>TimerThread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                <span class="keyword">boolean</span> taskFired;</span><br><span class="line">                <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)<span class="comment">//队列为空一直等待</span></span><br><span class="line">                        queue.wait();</span><br><span class="line">                    <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                        <span class="keyword">break</span>; </span><br><span class="line">                    <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                    task = queue.getMin();<span class="comment">//获取任务</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="keyword">continue</span>;  </span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        executionTime = task.nextExecutionTime;</span><br><span class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">//代表任务仅执行一次</span></span><br><span class="line">                                queue.removeMin();<span class="comment">//从队列中移除</span></span><br><span class="line">                                task.state = TimerTask.EXECUTED;<span class="comment">//改变任务状态</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">//周期的执行</span></span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</span><br><span class="line">                                                : executionTime + task.period);<span class="comment">//重新排列队列里的任务</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">//未到达时间则等待</span></span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskFired) <span class="comment">//达到条件则执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>TimerThread</code>类中主要的就是<code>mainLoop</code>方法，通过无限循环来从队列中取任务来执行，如果队列为空且newTasksMayBeScheduled为true时则会一直等待，在executionTime 时间小于当前时间的情况下会去判断下周期值period，如果period小于0则会更新更新任务上的nextExecutionTime时间为当前时间减去period时间，此时更新后的nextExecutionTime时间就大于了当前时间，并且当前任务会在队里重新排序，当下一次循环到此任务时则会等待(executionTime - currentTime)时间后才执行任务。如果在执行任务中出现了异常这里并没有做任务处理，在mainLoop最外层中的finally中会清除队列中的任务，并将newTasksMayBeScheduled设置为false。一旦一个任务中出现异常那么这个定时器将会失效，后面的任务就无法执行</p><h2 id="TaskQueue类"><a href="#TaskQueue类" class="headerlink" title="TaskQueue类"></a>TaskQueue类</h2><p>对于TaskQueue类我理解为是一个最小堆，里面的任务都是时间离当前时间最近的放在前面，添加任务时会将任务放在末尾然后从上下往上更新堆，删除时会将末尾的替换掉第一个，从上往下更新。TaskQueue实例化时，会默认初始一个长度为128的TimerTask数组，来存储TimerTask，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>]</span><br></pre></td></tr></table></figure></p><p>当想TaskQueue中add任务时，若内部数组已满，则将数组长度扩展为当前的2倍。下面看下几个主要方法</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TimerTask task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)<span class="comment">//判断是否需要扩容</span></span><br><span class="line">            queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</span><br><span class="line">        queue[++size] = task;<span class="comment">//这里首个任务的下标是1并不是1</span></span><br><span class="line">        fixUp(size);<span class="comment">//更新最小堆，从下往上</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加任务时会判断是否需要扩容，需要则扩为原来的2倍，不需要则将任务加在末尾然后更新最小堆</p><h3 id="removeMin方法"><a href="#removeMin方法" class="headerlink" title="removeMin方法"></a>removeMin方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue[<span class="number">1</span>] = queue[size];<span class="comment">//用末尾替换掉第一个</span></span><br><span class="line">        queue[size--] = <span class="keyword">null</span>;  </span><br><span class="line">        fixDown(<span class="number">1</span>);<span class="comment">//删除时的更新最小堆,从上往下</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除时会将末尾的替换成第一个，然后将末尾设置为null且大小减1，然后通过<code>fixDown</code>方法从上往下更新。</p><h3 id="fixUp方法"><a href="#fixUp方法" class="headerlink" title="fixUp方法"></a>fixUp方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加任务时更新堆，首先找到子节点的父节点然后进行比较，如果子小于父则两个进交换，进入下一次循环，若子大于父则跳出循环，这就保证了永远都是一个最小堆</p><h3 id="fixDown方法"><a href="#fixDown方法" class="headerlink" title="fixDown方法"></a>fixDown方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; size &amp;&amp;</span><br><span class="line">                queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</span><br><span class="line">                j++; <span class="comment">// j indexes smallest kid</span></span><br><span class="line">            <span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除任务时更新堆，从根部从上往下，先找子节点，然后再进行比较，将最小的那个子节点与它交换位置，然后进入下次循环</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Timer的任务是单线程来执行的，即只有一个线程来执行所有的任务</li><li>由于Timer只有一个线程来按顺序执行任务，当某一个任务执行失败而抛异常，这会导致后面的任务将无法被执行，所以建议当有定时任务的时候最好使用<code>ScheduledThreadPoolExecutor</code>来完成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Timer是jdk1.3中自带的一种线程调度任务的工具。可以执行一个只调度一次的任务也可以重复调度一个一定间隔时间的任务。&lt;/p&gt;
&lt;h2 id=&quot;成员变量&quot;&gt;&lt;a href=&quot;#成员变量&quot; class=&quot;headerlink&quot; title=&quot;成员变量&quot;&gt;&lt;/a&gt;成员变量&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//任务队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; TaskQueue queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TaskQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定时调用任务的线程类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; TimerThread thread = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TimerThread(queue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Object threadReaper = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//用于生成调度线程的名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; AtomicInteger nextSerialNumber = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;构造器&quot;&gt;&lt;a href=&quot;#构造器&quot; class=&quot;headerlink&quot; title=&quot;构造器&quot;&gt;&lt;/a&gt;构造器&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Timer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Timer-&quot;&lt;/span&gt; + serialNumber());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Timer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isDaemon)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Timer-&quot;&lt;/span&gt; + serialNumber(), isDaemon);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Timer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.setName(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Timer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isDaemon)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.setName(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.setDaemon(isDaemon);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们实例化一个Timer类的时候会为线程设置一个名字并启动此线程然后一直处于等待状态直到到队列中加入任务&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="timer" scheme="https://cqjokers.top/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>记录线上程序导致服务器CPU过高的问题排除过程</title>
    <link href="https://cqjokers.top/note/2018/07/13/ec3f81d6.html"/>
    <id>https://cqjokers.top/note/2018/07/13/ec3f81d6.html</id>
    <published>2018-07-13T09:36:30.000Z</published>
    <updated>2018-07-31T01:15:51.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><p>昨天上午朋友告诉我之前我做的一个外包项目(抓取公共运输整合资讯流通服务平台上的数据)突然无法访问了，通过浏览器访问一直处于等待状态，于是我登录服务器查看CPU使用率发现，CPU占用达到80%以上，而java进程CPU占有率则是达到350%以上。</p><h2 id="问题查找"><a href="#问题查找" class="headerlink" title="问题查找"></a>问题查找</h2><p>查看当前服务器CPU占有率最简单的方法就是通过top命令查看<img src="https://upload-images.jianshu.io/upload_images/13023122-5480faab09f208ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">根据上图发现pid为27055的进程CPU占有率达到353.2%，于是通过<code>top -p 27055 -H</code>命令把该进程的所有线程都显示出来，然后发现几个占用CPU资源特别大的线程tid如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-8cd16dc2bf1d1e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">根据上图所示发现有4个线程占用CPU非常高<br><a id="more"></a></p><h2 id="分析线程堆栈"><a href="#分析线程堆栈" class="headerlink" title="分析线程堆栈"></a>分析线程堆栈</h2><p>首先通过<code>jstack 27055 &gt; java-stack.log</code>命令将堆栈信息导出到日志文件里，然后将之前看到的线程ID转为16进制在日志文件里进行查找发现这4个线程是垃圾回收线程，分析图如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/13023122-90a35033582f4d69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">也可以将堆栈日志上传这上网上进行分析<a href="http://heaphero.io" target="_blank" rel="noopener">Fast thread</a>如果日志文件太大最好还是使用MAT工具进行分析。<br>由于之前写的几个并没有出现这样的问题，是最近新添的几个抓取网址才导致出现CPU飙高，通过fastThread进行分析发现有几个线程执行的代码是一样的，但是按照正常流程该段代码只会出现在一个线程，如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13023122-c463bf338c18dc4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">上图标红的这几个线程都是执行最近新添的代码，并且发现都卡在了<code>startHandshake</code>这里，在网上搜索发现也有其它小伙伴遇见这个问题。由于抓取的数据量非常大所以执行的时间会比较久再加上自己手贱在定时执行线程中又包了一个子线程，所以导致了上面出现的几个线程同时执行同一段代码，通过浏览器不用https访问发现一样可以取到数据，然后果断的将后台上的网址换掉。通过优化代码和更换网址后从昨天到今天暂时未发现CPU占用较高的问题</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过这次问题发现，线程一定不要乱用，凡是用到多线程的地方一定要谨慎思考</li><li>对于分析问题也会有不少的收获，一些基本的JVM命令需要去了解并在发现问题时知道怎么用。</li><li>对于java程序而言，CPU占用过高大多数是因为内存不够，而GC又回收不了导致的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;故障描述&quot;&gt;&lt;a href=&quot;#故障描述&quot; class=&quot;headerlink&quot; title=&quot;故障描述&quot;&gt;&lt;/a&gt;故障描述&lt;/h2&gt;&lt;p&gt;昨天上午朋友告诉我之前我做的一个外包项目(抓取公共运输整合资讯流通服务平台上的数据)突然无法访问了，通过浏览器访问一直处于等待状态，于是我登录服务器查看CPU使用率发现，CPU占用达到80%以上，而java进程CPU占有率则是达到350%以上。&lt;/p&gt;
&lt;h2 id=&quot;问题查找&quot;&gt;&lt;a href=&quot;#问题查找&quot; class=&quot;headerlink&quot; title=&quot;问题查找&quot;&gt;&lt;/a&gt;问题查找&lt;/h2&gt;&lt;p&gt;查看当前服务器CPU占有率最简单的方法就是通过top命令查看&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13023122-5480faab09f208ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;根据上图发现pid为27055的进程CPU占有率达到353.2%，于是通过&lt;code&gt;top -p 27055 -H&lt;/code&gt;命令把该进程的所有线程都显示出来，然后发现几个占用CPU资源特别大的线程tid如下图所示：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13023122-8cd16dc2bf1d1e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;根据上图所示发现有4个线程占用CPU非常高&lt;br&gt;
    
    </summary>
    
      <category term="错误分析" scheme="https://cqjokers.top/categories/%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="thread" scheme="https://cqjokers.top/tags/thread/"/>
    
      <category term="dump" scheme="https://cqjokers.top/tags/dump/"/>
    
      <category term="Analysis" scheme="https://cqjokers.top/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap底层分析</title>
    <link href="https://cqjokers.top/note/2018/07/12/87d7104e.html"/>
    <id>https://cqjokers.top/note/2018/07/12/87d7104e.html</id>
    <published>2018-07-12T09:37:34.000Z</published>
    <updated>2018-07-31T01:15:51.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>由于LinkedHashMap是在HashMap之上进行的，所以要理解LinkedHashMap需要先了解HashMap的原理。对HashMap的理解可以参考之前写的<a href="http://cqjokers.top/2018/07/09/java/HashMap/">HashMap分析</a>，LinkedHashMap继承了HashMap，所以LinkedHashMap其实也是散列表的结构，不同的是LinkedHashMap是运用双向链表而HashMap是运用单向链表，通过源代码中的注释可以知道它使用链表来维护数据的有序性。<br><a href="https://i.loli.net/2018/07/12/5b46c00fabed9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/07/12/5b46c00fabed9.png" alt="LinkedHashMap.png"></a></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部静态类，元素的存储结构，继承至HashMap.Node,扩展为一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//此属性可以控制元素顺序，默认false,顺序为插入时的顺序</span></span><br><span class="line"><span class="comment">//为true时对集合里的数操作时会将数据放入尾部，通过它可以实现LRU缓存</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>由于LinkedHashMap继承了HashMap所以其内部属性就比较少，通过head,tail来保存首尾元素，静态类Entry继承Node,并扩展为一个双向链表，通过<code>accessOrder</code>我们可以控制元素的顺序<br><a id="more"></a></p><h2 id="元素创建"><a href="#元素创建" class="headerlink" title="元素创建"></a>元素创建</h2><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);<span class="comment">//创建新节点</span></span><br><span class="line">    linkNodeLast(p);<span class="comment">//链接节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树方式创建节点</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在put新元素时会通过newNode创建新节点，与HashMap不同的是这里创建节点后会将节点与前一个关联起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;<span class="comment">//保存尾部节点</span></span><br><span class="line">    tail = p;<span class="comment">//修改尾部节点为当前新节点</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)<span class="comment">//如果之前的尾部节点为空说明集合里还没有元素</span></span><br><span class="line">        head = p;<span class="comment">//修改头节点为当前新节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;<span class="comment">//设置当前节点的前置节点为原尾部节点</span></span><br><span class="line">        last.after = p;<span class="comment">//设置原尾部节点的后置节点为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>linkNodeLast</code>方法可以将新元素关联到链表尾部，并将其与前一个节点关联上</p><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><hr><p>在HashMap中预留了三个方法给LinkedHashMap,通过这三个方法可以保证链表的插入、删除的有序性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<span class="comment">//访问的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;<span class="comment">//插入后的回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;<span class="comment">//删除后的回调</span></span><br></pre></td></tr></table></figure></p><h3 id="afterNodeAccess方法"><a href="#afterNodeAccess方法" class="headerlink" title="afterNodeAccess方法"></a>afterNodeAccess方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// 移动节点到尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="comment">//如果accessOrder为true且当前访问的节点不是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            <span class="comment">//节点e强转成双向链表节点p,保存前置节点与后置节点</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;<span class="comment">//将后置节点置为null</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)<span class="comment">//说明原节点是首节点</span></span><br><span class="line">                head = a;<span class="comment">//将原节点的后置节点提升为首节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;<span class="comment">//更新p的前置节点b的后置节点为a</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)<span class="comment">//p的后置节点不为null</span></span><br><span class="line">                a.before = b;<span class="comment">//更新p的后置节点a的前置节点为b</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//说明原节点就是尾节点</span></span><br><span class="line">                last = b;<span class="comment">//更新尾节点为原节点的前置节点b</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)<span class="comment">//如果尾节点为空说明链表中就只有一个节点就是p</span></span><br><span class="line">                head = p;<span class="comment">//更新头节点为p</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;<span class="comment">//更新当前节点p的前置节点为原尾节点last</span></span><br><span class="line">                last.after = p;<span class="comment">//更新last的后置节点是p</span></span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;<span class="comment">//更新p为链表尾节点</span></span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过afterNodeAccess方法将当前节点移至链表尾部，但有一个条件就是当accessOrder为true时才会执行这个操作，在HashMap的putVal方法中，就调用了这个方法。</p><h3 id="afterNodeInsertion方法"><a href="#afterNodeInsertion方法" class="headerlink" title="afterNodeInsertion方法"></a>afterNodeInsertion方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会在链表中插入一个新节点的时候调用，目的是删除链表的首节点，当然需要重写<code>removeEldestEntry</code>方法因为默认是返回false，通过<code>afterNodeAccess</code>方法与<code>afterNodeInsertion</code>方法我们可以实现一个LRU缓存</p><h3 id="afterNodeRemoval方法"><a href="#afterNodeRemoval方法" class="headerlink" title="afterNodeRemoval方法"></a>afterNodeRemoval方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>afterNodeRemoval</code>方法主要目的是在移除数据后将双向链表中该节点一并移除掉</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法与HashMap里的get方法不同的是当<code>accessOrder</code>为true时会回调<code>afterNodeAccess</code>方法</p><h3 id="getOrDefault方法"><a href="#getOrDefault方法" class="headerlink" title="getOrDefault方法"></a>getOrDefault方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会根据key去查找数据，如果没有找到则返回默认值<code>defaultValue</code>，若找到则返回节点数据，最后判断<code>accessOrder</code>是否为true，若是则执行afterNodeAccess方法</p><h3 id="containsValue方法"><a href="#containsValue方法" class="headerlink" title="containsValue方法"></a>containsValue方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比HashMap里的效率要高，HashMap里使用了两个循环，这里只对链表从前往后查找</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ul><li>LinkedHashMap继承了HashMap，所以HashMap存在的问题它也一样会存在</li><li>可以利用LinkedHashMap构造一个LRUCache，条件是需要将accessOrder设置为true，并重写<code>removeEldestEntry</code>方法</li><li>LinkedHashMap插入的数据是有序的，而HashMap存入的数据是无序的</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;由于LinkedHashMap是在HashMap之上进行的，所以要理解LinkedHashMap需要先了解HashMap的原理。对HashMap的理解可以参考之前写的&lt;a href=&quot;http://cqjokers.top/2018/07/09/java/HashMap/&quot;&gt;HashMap分析&lt;/a&gt;，LinkedHashMap继承了HashMap，所以LinkedHashMap其实也是散列表的结构，不同的是LinkedHashMap是运用双向链表而HashMap是运用单向链表，通过源代码中的注释可以知道它使用链表来维护数据的有序性。&lt;br&gt;&lt;a href=&quot;https://i.loli.net/2018/07/12/5b46c00fabed9.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/07/12/5b46c00fabed9.png&quot; alt=&quot;LinkedHashMap.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//内部静态类，元素的存储结构，继承至HashMap.Node,扩展为一个双向链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HashMap&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; before, after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(hash, key, value, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//头指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//尾指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//此属性可以控制元素顺序，默认false,顺序为插入时的顺序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//为true时对集合里的数操作时会将数据放入尾部，通过它可以实现LRU缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; accessOrder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于LinkedHashMap继承了HashMap所以其内部属性就比较少，通过head,tail来保存首尾元素，静态类Entry继承Node,并扩展为一个双向链表，通过&lt;code&gt;accessOrder&lt;/code&gt;我们可以控制元素的顺序&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://cqjokers.top/categories/java/"/>
    
    
      <category term="map" scheme="https://cqjokers.top/tags/map/"/>
    
  </entry>
  
</feed>
