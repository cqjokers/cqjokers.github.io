<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap分析]]></title>
    <url>%2F2018%2F07%2F09%2Fjava%2FHashMap%2F</url>
    <content type="text"><![CDATA[基本组成成员 1234567891011121314151617181920//默认容量,数组长度16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//最大容量,数组最大长度static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//负载因子，默认0.75fstatic final float DEFAULT_LOAD_FACTOR = 0.75f;//将链表转为红黑树的阀值，默认为8static final int TREEIFY_THRESHOLD = 8;//将红黑树转为链表的阀值，默认为6static final int UNTREEIFY_THRESHOLD = 6;//Node类型的数组transient Node&lt;K,V&gt;[] table;//实际存储的键值对个数transient int size;//用于迭代防止结构性破坏的标量transient int modCount;//扩容阀值，threshold = loadFactor * capacityint threshold;//负载因子变量final float loadFactor; HashMap 是 Map 的一个实现类，它代表的是一种键值对的数据存储形式,Key 不允许重复出现,但可以储存null键值,在jdk8中其内部是由数组+链表+红黑树来实现 构造方法 123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; HashMap一共有4个构造方法，如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值，initialCapacity默认为16，loadFactory默认为0.75，初始的时候并没有为Node数组分配内存空间，而是在put的时候进行分配 hash的计算 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，而Node数组下标计算则是按照下面方式进行计算：1(n - 1) &amp; hash put方法具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断是否初始了，若没有则初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //判断当前下标是否有数据，没有则存入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //有数据则放入链表尾部 else &#123; Node&lt;K,V&gt; e; K k; //当前节点与要插入的节点为同一个，此时仅仅是修改操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //当前节点是红黑树节点，则以红黑树方式插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //遍历链表，将节点插入尾部 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //判断是否需要将链表变为红黑白树，大于等于8时进行转换 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //添加后，是否达到扩容阀值，如果是则需要进行扩容操作 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 执行流程如下： 判断table数级是否初始化了，如果没有则进行初始化resize() 根据(n - 1) &amp; hash得到数组下标，判断当前索引是否存储得有数据，如果没有则创建node节点并插入 如果上面步骤有数据则判断当前节点是否与将要插入的节点为同一个，如果是则仅仅是修改操作，否则执行下面步骤 判断当前节点是否为红黑树节点，如果是则按照红黑树节点方式插入，否则执行下面步骤 遍历链表，将要插入的节点放入尾部，需要判断是否需要转换为红黑树，若满足要求则进行转换 最后添加节点后需要判断是否需要进行扩容操作get具体实现 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //对table进行校验，判断是否为空，长度是否大于0，取出的数据是否不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //判断当前下标里的第一个节点是否就是所要查找的，若是则直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //第一个节点不是所查找的则遍历查找 if ((e = first.next) != null) &#123; // 若节点是红黑树节点，则按红黑树方式进行查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //遍历链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 执行流程如下： 首选对table数组进行校验，判断是否不等于null,长度是否大于0，取出的数据是否不等于null,若条件满足则执行下面步骤 判断上一步取出的节点里的hash与key是否与当前查找的hash，key相等，如果相等则直接返回当前节点，否则继续往下执行 根据第一节点判断是否为红黑树节点，若是则按红黑树方式进行查找，否则遍历链表进行查找，直到找到为止remove具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //对table进行校验，判断是否为空，长度是否大于0，取出的数据是否不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //判断当前下标里的第一个节点是否就是所要查找的，若是则赋值给局部变量node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123;//若不是所要找的则判断下一节点是否为不等于null if (p instanceof TreeNode)//如果第一个节点为红黑树节点则按红黑树方式查找 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //遍历链表查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //得到所要移除的节点与传入的value进行比较判断是否为同一个 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode)//按照红黑树方式移除 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p)//所要移除的就是首节点则直接将下一个节点提为首节点 tab[index] = node.next; else p.next = node.next;//将所要移除节点的后置节点挂到它前置节点的next上 ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 执行流程如下： 前面部分与get方法类似，先去查找所要称除的节点，唯一不同的是get方法是查找到后直接返回，这里是将值赋值给了局部变量node 得到所要移除的节点后，将其与传入的参数value进行比较，如果条件满足则继续往下面执行 判断所要移除的节点是否为红黑树节点，若是则按红黑树方式进行移除 上一步若不满足，则判断所要移除的节点是否为首节点，若是则将其后置节点提升为首节点 上一步若不满足，则将所要移除节点的后置节点挂到它前置节点的next上resize方法具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //未超过最大值则扩容为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold //使用了initialCapacity参数的构造器，首次扩容则会到这里 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //使用了未带参数的构造器，首次扩容则会到这里 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //旧数组不为 null，这次的 resize 是一次扩容行为 if (oldTab != null) &#123; //遍历方式把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null)//首节点则直接分配 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)//红黑树节点方式分配 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123;//索引值不会发生变化 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123;//索引值发生变化，原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //下面主要是将链表上的数据按照e.hash &amp; oldCap不等0的将分配到原索引+oldCap的链表上 //原索引存入 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap存入 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 执行流程如下： 如果是第一次扩容，首先会根据选用的构造器来进入不同的条件，上面代码中已有注释 循环遍历，将原索引链表上的一部数据分配到新索引链表上，计算方式为（e.hash &amp; oldCap） == 0，如果为0则不发生改变，否则将分配到新索引链表上去，这样做的好处是避免了重新计算hash值，将数据均匀分散减少碰撞几率##总结： 根据分析可知,HashMap内部的储存依赖hash值的计算，所以选用String，Integer这些类做为键会提高HashMap的效率,因为他们本身具备作为键值的天生条件( hashCode(),equal()方法) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap 由于扩容是一个特别耗性能的操作，所以在使用HashMap的时候最好估算下map大小，给一个值避免频繁的进行扩容]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池分析]]></title>
    <url>%2F2018%2F07%2F05%2Fjava%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[为什么需要线程池 线程是稀缺资源，频繁的创建对系统资源消耗较大 线程池可以减少创建和销毁线程的次数并且可以复用线程池的创建 线程池的创建会借助于它的工厂类Executors来创建，主要有如下几种(jdk1.7)： newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 初始化一个只有一个线程的线程池，内部使用的是LinkedBlockingQueue作为阻塞队列，如果该线程异常结束则会创建一个新的线程来继续执行任务，这就保证了所提交的任务顺序执行。 newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 初始化一个指定固定大小的线程池，其中核心线程数与最大线程数是一样的，其内部使用LinkedBlockingQueue作为阻塞队列，当线程池没有可执行任务时，也不会释放线程。 newCachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 初始化一个可缓存线程的线程池，可创建的最大线程数为Integer.MAX_VALUE，内部使用的是SynchronousQueue作为阻塞队列，默认缓存时间为60s，在没有任务可执行时，当线程的空闲时间超过keepAliveTime时会自动释放线程资源，当提交新任务时，如果此时没有空闲的线程，则会创建新线程执行任务，因此会导致一定的系统开销，所以在使用此线程时需要注意并发的任务数，以防创建大量的线程导致性能降低。 newScheduledThreadPool123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据.1、ScheduledExecutorService其中的scheduleAtFixedRate方法，当程序执行时间&lt;频率时间（period）时，则下次执行开始时间=上一次执行开始时间+频率时间（period），当程序执行时间&gt;频率时间（period）时，则会在上一次执行结束后立即进入下一次执行2、ScheduledExecutorService其中的scheduleWithFixedDelay方法,程序会上一次执行结束后等待(period)时间再进行下一次执行 以上几个除了newScheduledThreadPool内部实现使用的是ScheduledThreadPoolExecutor外其它都是基于ThreadPoolExecutor类实现 ThreadPoolExecutor对象 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize：线程池核心线程数（提交新任务时，如果当前线程数小于corePoolSize则会创建新的线程执行任务直到当前线程数等于corePoolSize，如果当前线程数等于corePoolSize则会将新提交的任务放入阻塞队列中，如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程） maximumPoolSize：线程池最大线程数(当前队列已满时，如果线程数小于maximumPoolSize则会创建新的线程执行新提交的任务) keepAliveTime：线程空闲时存活时间，只有当线程数大于corePoolSize时此参数才会生效 unit：时间单位（keepAliveTime） workQueue：保存实现了Runable接口的任务阻塞队列,关于workQueue值jdk提供了以下几种供选择：1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene4、priorityBlockingQuene：优先级无界阻塞队列 threadFactory:创建线程的工厂，可以通过自定义的线程工厂给每个新建的线程设置一个具有识别度的线程名 handler：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了以下几种：1、ThreadPoolExecutor.AbortPolicy：直接抛出RejectedExecutionException异常，默认策略2、ThreadPoolExecutor.DiscardPolicy：直接丢弃任务与AbortPolicy不同的是不会抛出异常3、ThreadPoolExecutor.DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务，并执行当前任务4、ThreadPoolExecutor.CallerRunsPolicy：用调用者所在的线程来执行任务可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略 执行流程 如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务 如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中 如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务 如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略线程池状态 RUNNING：-1&lt;&lt;COUNT_BITS，即高3位为111，低29位为0，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务 SHUTDOWN：0&lt;&lt;COUNT_BITS，即高3位为000，低29位为0，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务 STOP：1&lt;&lt;COUNT_BITS，即高3位为001，低29位为0，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务 TIDYING：2&lt;&lt;COUNT_BITS，即高3位为010，低29位为0，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法 TERMINATED：3&lt;&lt;COUNT_BITS，即高3位为100，低29位为0，terminated()方法调用完成后变成此状态execute 12345678910111213141516171819202122232425public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //根据workerCountOf方法计算出当前线程数，判断当前线程数是否小于核心线程数 if (workerCountOf(c) &lt; corePoolSize) &#123; // 执行addWorker方法创建新的线程执行任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; //执行addWorker失败，判断线程池是否正在运行并且将任务加入队列中 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //再次校验，线程池不是RUNNING状态且成功从阻塞队列中删除任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果当前worker数量为0，通过addWorker(null, false)创建一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false);//未指定firstTask,第二个参数 ? corePoolSize：maxPoolSize &#125; //如果线程池不是运行状态或者进入队列失败，执行addWorker方法 else if (!addWorker(command, false)) reject(command);//addWorker方法执行失败，则拒绝当前command &#125; 执行流程如下 通过workerCountOf方法得到线程池当前线程数，如果当前线程数小于corePoolSize则通过addWorker(command, true)方法创建新worker线程，如创建成功返回，否则继续下面的步骤 如果线程池处于RUNNING状态，且把任务成功放入阻塞队列中,如果加入失败则继续执行后面的步骤1、如果线程池已经不是running状态了且从workQueue中删除任务成功，则拒绝添加新任务2、如果线程池是运行状态，或者从workQueue中删除任务失败且当前worker数量为0则执行addWorker(null, false)创建一个线程 如果线程池不是运行状态或者无法入队列则拒绝添加新任务 addWorker 字面意思就是添加worker线程,主要负责创建新的线程并执行任务,代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //如果线程池状态大于或等于SHUTDOWN且后面三个条件中有一个为false则不会继续进行 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c);//worker数量 //如果worker数量&gt;线程池最大上限CAPACITY //或者( worker数量&gt;corePoolSize 或 worker数量&gt;maximumPoolSize )则返回不再进行曳光弹 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //cas操作，使得worker数量加1 if (compareAndIncrementWorkerCount(c)) break retry;//跳出retry循环 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs)//如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);//创建一个worker线程 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock();//加锁 try &#123; int rs = runStateOf(ctl.get()); //线程池状态小于SHUTDOWN或者（为SHUTDOWN状态且firstTask==null） if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w);//将worker线程加入HashSet中(workers是一个HashSet) //设置最大的池大小largestPoolSize，workerAdded设置为true int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock();//释放锁 &#125; if (workerAdded) &#123;//加入HashSet成功 t.start();//启动线程 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker执行流程如下： 判断线程池状态是否为可以添加worker线程的状态，如果是则继续下一步，否则返回false 判断线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），如果超过则return false，否则对workerCount+1，继续往下执行 在线程池的ReentrantLock保证下，向Workers中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这几步操作都成功则返回true否则调用addWorkerFailed()逻辑 worker类 线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例添加到HashSet后，并启动Woker中的线程，其中Worker类设计如下：123private final class Worker extends AbstractQueuedSynchronizer implements Runnable 继承了AQS(AbstractQueuedSynchronizer)类，可以方便的实现工作线程的中止操作； 实现了Runnable接口，可以将自身作为一个任务在工作线程中执行； 当前提交的任务firstTask作为参数传入Worker的构造方法创建worker时初始化AQS的状态为-1，将当前提交的任务firstTask作为参数传入构造方法并创建Thread12345Worker(Runnable firstTask) &#123; setState(-1); // 这所以初始化为-1是为了防止被中断 this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; 初始AQS状态为-1，此时不允许中断interrupt()，只有在worker线程启动了，执行了runWoker()，将state置为0，才能中断，为了防止运行中的worker被中断，所以runWorker()每次运行任务时都会lock()上锁，在调用shutdown时会先去获得worker锁后才能再中断这样就防止了中断运行中的worker1234567protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123;//这里不是加1操作而是将state从0设置为1所以规避了重入锁 setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; runWorker 1234567891011121314151617181920212223242526272829303132333435363738394041424344final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // 释放锁,将state置为0，interruptIfStarted只有state&gt;=0时才能调用中断 boolean completedAbruptly = true; try &#123; //如果task不等于null或者从队列中取出的task不等于null while (task != null || (task = getTask()) != null) &#123; w.lock();//上锁，防止调用shutdown时中断正在运行的任务 //两种情况： //1、当前线程池状态&gt;=stop且没有设置中断状态则wt.interrupt //2、如果第一个条件&lt;stop，但线程已经被中断，又清除了中断标示，再次判断线程池状态是否&gt;=stop //如果是则wt.interrupt() if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt();//调用中断操作 try &#123; beforeExecute(wt, task);//任务执行前的操作 Throwable thrown = null; try &#123; task.run();//执行任务 &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown);//任务执行后的操作 &#125; &#125; finally &#123; task = null; w.completedTasks++;//完成任务数+1 w.unlock();//释放锁 &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly);//执行worker退出 &#125; &#125; 执行流程如下： 线程启动后通过释放锁将AQS的state置为0，允许中断当前worker线程 执行firstTask调用task.run()，在执行之前会进行加锁操作，执行完后会释放锁，目的是防止在任务运行时被线程池一些中断操作中断 如果自己的业务需要在任务执行前后进行操作，可以自定义beforeExecute和afterExecute方法 当前任务执行完后，会通过getTask()从阻塞队列中获取新任务，如果队列中没有任务或者获取超时则当前worker则会执行退出流程 getTask 12345678910111213141516171819202122232425262728293031323334private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 如果当前线程池状态&gt;=SHUTDOWN 且(线程池状态&gt;=STOP 或者队列为空)时，会减少worker数量，并返回null if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount();//cas操作减少worker数量，循环操作 return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //wc&gt;maximumPoolSize且队列为空，或者timed与timedOut都为ture且(wc &gt; 1 || 队列为空) if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ://wc &gt; corePoolSize workQueue.take();//wc&lt; corePoolSize if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 执行流程如下： 判断线程池状态是否满足，线程池为shutdown且( workQueue为空或者stop状态)都不满足，则会cas操作减少worker数量并返回null 线程数量是否超过maximumPoolSize或者获取任务超时且(线程数大于1或者队列为空)，则会cas操作减少worker数量并返回null 如果满足获取任务条件，根据是否需要定时获取调用不同方法： 1、workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null 2、workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务 在阻塞从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程 参考资料：Java线程池ThreadPoolExecutor使用和分析]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pool</tag>
      </tags>
  </entry>
</search>
