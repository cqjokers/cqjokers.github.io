<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一致性Hash分析]]></title>
    <url>%2F2018%2F07%2F18%2Falgorithm%2Fconsisten-hash%2F</url>
    <content type="text"><![CDATA[场景描述在开发中经常会用到缓存来减轻数据库的压力，比较常见的就是使用redis，但当数据达到一定量时一台缓存服务器已经无法满足现在的需求，所以需要进行分布存储，假设现在有3台缓存服务器，那么该如何将数据均匀的分布到这3台服务器上了。 取模运算方式将传入的Key按照index = hash(key) % len方式计算出需要存放的服务器节点，其中len是服务器数量，通过取模运算就能将数据均匀的分布到不同的服务器上。但这种方式有缺陷，如果某一天老板说再加一台服务器，此时服务器数就变成了4，那么通过上面方式来获取数据很有可能不会命中，因为重新计算了key，换句话说当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时则会向后端服务器请求数据。同理，假设缓存服务器中突然有一台务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，如果想要访问数据，这条数据的缓存位置必定会发生改变，之前缓存的数据也失去了缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时后端服务器将会承受巨大的压力，整个系统很有可能被压垮。 一致性Hash算法一致 Hash 算法是将所有的哈希值构成了一个环，其范围在 0 ~ 2^32-1，就像吃的饼子一样，饼子我们可以理解为是由0~60个点组成的圆，那么在这里我们可以理解为由0~2^32-1个点组成的圆，如下图所示：然后通过hash计算将各个节点分配到这个环上，hash计算时可以通过服务器IP+服务器名称等作为唯一key来进行hash(key)计算，假如分配后的图如下：假如现在我们需要进行数据缓存，那么我们使用hash(key)方式将key映射到环上，如下图所示：现在已经把服务器与数据都映射到这个环上了，但是数据k1会存入哪一台服务器了，这里的数据k1将会存储在s2服务器上，因为从数据在环上的的位置开始顺时针方向找到的第一个服务器就是s2,所以上图中的数据k1会缓存到s2服务器上，如下图所示： 容错性假如现在我们有一台服务器s1宕机了，那么此时受影响的其实只有k3数据它将会重新映射到S2服务器上，k1,k2其实是没有发生变化的，如下图所示： 扩展性假如现在我们需要在之前3台服务器的基础上再加一台服务器s4，恰好映射在s2与s3之间，那么此时受影响的只有k2，而k1与k3没有发生变化，如下图所示： 环的偏斜在上面的图中我们都是以最好的情况来分析的，想像的是服务器是均匀的分布到这个环上面，然后实际开发中，其实并不一定是均匀分布的，会出现映射的节点偏向某一个方向的情况，这种情况很容易造成数据分布不均匀，如下图所示：如上图所示，数据分布在S1服务器上的最多 虚拟节点为了应对环的偏斜我们可以添加虚拟节点来弥补，虚拟节点其实就是实际服务器节点的复制品，一个实际节点可以对应多个虚拟节点，我们在生成虚拟节点时，可以在实际服务器IP地址后面加上序号号通过hash计算来生成，如下图所示：上图中s11,s21,s31就是生成的虚拟节点，这样缓存的分布就均匀得多了，还可以添加更多的虚拟节点来解决环的偏斜，虚拟节点越多缓存分布越均匀。 总结 在进行分布式存储开发中，最好使用一致性Hash来均匀的存放数据 当服务器较少时，可以添加虚拟节点来解决环的偏斜，从而使得数据均匀的分布到服务器上。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LruCache的简单实现]]></title>
    <url>%2F2018%2F07%2F17%2Falgorithm%2FLruCache%2F</url>
    <content type="text"><![CDATA[由于前面分析过LinkedHashMap，知道其内部运用了一个双向链表结构来存储数据，所以能够保证数据的有序性，并且源代码里预留了三个方法，我们可以基于它们来实现一个LRU缓存。12345678910111213141516171819public class LRUHashMap&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final long serialVersionUID = 1L; //最大缓存数目 private final int maxCapacity; //负载因 private static final float DEFAULT_LOAD_FACTOR = 0.75f; public LRUHashMap(int maxCapacity) &#123; super(maxCapacity, DEFAULT_LOAD_FACTOR, true); this.maxCapacity = maxCapacity; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; maxCapacity; &#125; &#125; 由于LinkedHashMap是线程不安全的，所以要想在多线程环境使用可以使用 Collections.synchronizedMap()方法实现线程安全操作 自己实现一个LRU缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class LRUCache&lt;K,V&gt; &#123; //缓存最大数目 private int maxCacheSize; //头节点 private Node&lt;K,V&gt; head; //尾节点 private Node&lt;K, V&gt; tail; private final Map&lt;K, Node&gt; cacheMap = new HashMap&lt;K, Node&gt;(); public LRUCache(int maxCacheSize) &#123; this.maxCacheSize = maxCacheSize; &#125; public V get(K key) &#123; if(cacheMap.containsKey(key)) &#123; Node node = cacheMap.get(key); removeNode(node); addNode(node); return (V) node.value; &#125; return null; &#125; public void put(K key,V value) &#123; //判断是否已经存在 if(cacheMap.containsKey(key)) &#123; //移动到首部 Node node = cacheMap.get(key); removeNode(node); addNode(node); &#125; else &#123; //添加节点到首部 Node&lt;K, V&gt; node = new Node&lt;K, V&gt;(key, value); cacheMap.put(key, node); addNode(node); &#125; &#125; public int size() &#123; return cacheMap.size(); &#125; private void addNode(Node node) &#123; if(cacheMap.size() &gt; maxCacheSize) &#123; cacheMap.remove(tail.key); //删除尾节点 removeNode(tail); &#125; node.before = null; Node h = head; head = node; if(h == null) tail = node; else &#123; node.after = h; h.before = node; &#125; &#125; /** * 移除节点 * @param node */ private void removeNode(Node node) &#123; if(node.after == null) tail = node.before; else node.after.before = node.before; if(node.before == null) head = node.after; else node.before.after = node.after; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder() ; Node&lt;K,V&gt; node = tail ; while (node != null)&#123; sb.append(node.key).append(":") .append(node.value) .append("--&gt;") ; node = node.before ; &#125; return sb.toString(); &#125; private class Node&lt;K,V&gt; &#123; K key; V value; Node&lt;K,V&gt; before,after; public Node(K key,V value) &#123; this.key = key; this.value = value; &#125; &#125;&#125; 测试效果如下12345678910111213141516171819@Testpublic void test() &#123; LRUCache&lt;Integer, Integer&gt; cache = new LRUCache&lt;Integer, Integer&gt;(3); cache.put(1, 1); cache.put(2, 2); cache.put(3, 3); cache.put(4, 4); System.out.println(cache); cache.get(3); cache.put(5, 5); System.out.println(cache); cache.put(6, 6); System.out.println(cache);&#125;2:2--&gt;3:3--&gt;4:4--&gt;4:4--&gt;3:3--&gt;5:5--&gt;3:3--&gt;5:5--&gt;6:6--&gt; 内部使用的是一个HashMap存入数据，不过值是一个Node节点 使用了一个双向链表将各数据关联起来 由于存入的值是进行转换后的Node节点，所以在查询的时候，相比遍历整个链表效率要好一点 由于内部使用的是HashMap所以所有操作都是线程不安全的。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet原理分析]]></title>
    <url>%2F2018%2F07%2F15%2Fjava%2FHashSet%2F</url>
    <content type="text"><![CDATA[概述HashSet实现了Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；它并不保证随着时间的推移，秩序将保持不变。此类允许使用null元素,是一个不允许存储重复元素的集合 成员变量12private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object(); map:用于存放数据 PRESENT: 所有存入的map数据的value值 构造器1234567891011121314151617181920public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 通过构造器可以发现使用的是HashMap来初始化map，但其中有一个包访问级别的构造器，使用的是LinkedHashMap，其主要是对LinkedHashSet的支持。 add方法123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 通过add方法可以发现，存入的数据其实是作为了map的键，而真正的值是PRESENT,所以这就保证了存入的数据是没有重复的 总结 由于HashSet是借助于HashMap来实现的，所以HashMap会出现的问题,HashSet一样会出现 在用HashSet保存对象的时候，一定要正确的重写其equals和hashCode方法，以保证放入的对象的唯一性]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Timer底层分析]]></title>
    <url>%2F2018%2F07%2F14%2Fjava%2FTimer%2F</url>
    <content type="text"><![CDATA[Timer是jdk1.3中自带的一种线程调度任务的工具。可以执行一个只调度一次的任务也可以重复调度一个一定间隔时间的任务。 成员变量1234567//任务队列private final TaskQueue queue = new TaskQueue();//定时调用任务的线程类private final TimerThread thread = new TimerThread(queue);private final Object threadReaper = new Object();//用于生成调度线程的名字private final static AtomicInteger nextSerialNumber = new AtomicInteger(0); 构造器123456789101112131415public Timer() &#123; this("Timer-" + serialNumber());&#125;public Timer(boolean isDaemon) &#123; this("Timer-" + serialNumber(), isDaemon);&#125;public Timer(String name) &#123; thread.setName(name); thread.start();&#125;public Timer(String name, boolean isDaemon) &#123; thread.setName(name); thread.setDaemon(isDaemon); thread.start();&#125; 当我们实例化一个Timer类的时候会为线程设置一个名字并启动此线程然后一直处于等待状态直到到队列中加入任务 关键方法123456789101112//在指定延迟后执行指定的任务public void schedule(TimerTask task, long delay)//在指定时间执行任务public void schedule(TimerTask task, Date time)//任务从指定的延迟后开始进行重复的固定延迟执行public void schedule(TimerTask task, long delay, long period)//任务在指定的时间开始进行重复的固定延迟执行public void schedule(TimerTask task, Date firstTime, long period)//任务在指定的延迟后开始进行重复的固定速率执行public void scheduleAtFixedRate(TimerTask task, long delay, long period)//任务在指定的时间开始进行重复的固定速率执行public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period) schedule的重复执行与scheduleAtFixedRate的区别在于任务执行起始的时间基准点不一样，schedule下一次执行时间相对于上一次任务实际执行完成的时间点 ，而scheduleAtFixedRate下一次执行时间相对于上一次开始的 时间点 ，因此执行时间不会延后 核心方法12345678910111213141516171819202122private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException("Illegal execution time."); if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException("Timer already cancelled."); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( "Task already scheduled or cancelled"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125; &#125; 关键方法里最终都会调用sched方法，该方法主要是设置任务的开始执行时间，周期与状态，将任务加入到队列中，如果加入的任务与队列中的第一个相等则唤醒线程去执行。 TimerThread类123456789101112131415161718192021222324252627282930313233343536373839private void mainLoop() &#123; while (true) &#123; try &#123; TimerTask task; boolean taskFired; synchronized(queue) &#123; while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)//队列为空一直等待 queue.wait(); if (queue.isEmpty()) break; long currentTime, executionTime; task = queue.getMin();//获取任务 synchronized(task.lock) &#123; if (task.state == TimerTask.CANCELLED) &#123; queue.removeMin(); continue; &#125; currentTime = System.currentTimeMillis(); executionTime = task.nextExecutionTime; if (taskFired = (executionTime&lt;=currentTime)) &#123; if (task.period == 0) &#123; //代表任务仅执行一次 queue.removeMin();//从队列中移除 task.state = TimerTask.EXECUTED;//改变任务状态 &#125; else &#123; //周期的执行 queue.rescheduleMin( task.period&lt;0 ? currentTime - task.period : executionTime + task.period);//重新排列队列里的任务 &#125; &#125; &#125; if (!taskFired) //未到达时间则等待 queue.wait(executionTime - currentTime); &#125; if (taskFired) //达到条件则执行任务 task.run(); &#125; catch(InterruptedException e) &#123; &#125; &#125; &#125; TimerThread类中主要的就是mainLoop方法，通过无限循环来从队列中取任务来执行，如果队列为空且newTasksMayBeScheduled为true时则会一直等待，在executionTime 时间小于当前时间的情况下会去判断下周期值period，如果period小于0则会更新更新任务上的nextExecutionTime时间为当前时间减去period时间，此时更新后的nextExecutionTime时间就大于了当前时间，并且当前任务会在队里重新排序，当下一次循环到此任务时则会等待(executionTime - currentTime)时间后才执行任务。如果在执行任务中出现了异常这里并没有做任务处理，在mainLoop最外层中的finally中会清除队列中的任务，并将newTasksMayBeScheduled设置为false。一旦一个任务中出现异常那么这个定时器将会失效，后面的任务就无法执行 TaskQueue类对于TaskQueue类我理解为是一个最小堆，里面的任务都是时间离当前时间最近的放在前面，添加任务时会将任务放在末尾然后从上下往上更新堆，删除时会将末尾的替换掉第一个，从上往下更新。TaskQueue实例化时，会默认初始一个长度为128的TimerTask数组，来存储TimerTask，如下：1TimerTask[] queue = new TimerTask[128] 当想TaskQueue中add任务时，若内部数组已满，则将数组长度扩展为当前的2倍。下面看下几个主要方法 add方法123456void add(TimerTask task) &#123; if (size + 1 == queue.length)//判断是否需要扩容 queue = Arrays.copyOf(queue, 2*queue.length); queue[++size] = task;//这里首个任务的下标是1并不是1 fixUp(size);//更新最小堆，从下往上 &#125; 添加任务时会判断是否需要扩容，需要则扩为原来的2倍，不需要则将任务加在末尾然后更新最小堆 removeMin方法12345void removeMin() &#123; queue[1] = queue[size];//用末尾替换掉第一个 queue[size--] = null; fixDown(1);//删除时的更新最小堆,从上往下 &#125; 删除时会将末尾的替换成第一个，然后将末尾设置为null且大小减1，然后通过fixDown方法从上往下更新。 fixUp方法123456789private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125; &#125; 添加任务时更新堆，首先找到子节点的父节点然后进行比较，如果子小于父则两个进交换，进入下一次循环，若子大于父则跳出循环，这就保证了永远都是一个最小堆 fixDown方法123456789101112private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) &#123; if (j &lt; size &amp;&amp; queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) j++; // j indexes smallest kid if (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125; &#125; 删除任务时更新堆，从根部从上往下，先找子节点，然后再进行比较，将最小的那个子节点与它交换位置，然后进入下次循环 总结 Timer的任务是单线程来执行的，即只有一个线程来执行所有的任务 由于Timer只有一个线程来按顺序执行任务，当某一个任务执行失败而抛异常，这会导致后面的任务将无法被执行，所以建议当有定时任务的时候最好使用ScheduledThreadPoolExecutor来完成]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录线上程序导致服务器CPU过高的问题排除过程]]></title>
    <url>%2F2018%2F07%2F13%2F%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%2FJavaThreadDumpAnalysis%2F</url>
    <content type="text"><![CDATA[故障描述昨天上午朋友告诉我之前我做的一个外包项目(抓取公共运输整合资讯流通服务平台上的数据)突然无法访问了，通过浏览器访问一直处于等待状态，于是我登录服务器查看CPU使用率发现，CPU占用达到80%以上，而java进程CPU占有率则是达到350%以上。 问题查找查看当前服务器CPU占有率最简单的方法就是通过top命令查看根据上图发现pid为27055的进程CPU占有率达到353.2%，于是通过top -p 27055 -H命令把该进程的所有线程都显示出来，然后发现几个占用CPU资源特别大的线程tid如下图所示：根据上图所示发现有4个线程占用CPU非常高 分析线程堆栈首先通过jstack 27055 &gt; java-stack.log命令将堆栈信息导出到日志文件里，然后将之前看到的线程ID转为16进制在日志文件里进行查找发现这4个线程是垃圾回收线程，分析图如下图所示：也可以将堆栈日志上传这上网上进行分析Fast thread如果日志文件太大最好还是使用MAT工具进行分析。由于之前写的几个并没有出现这样的问题，是最近新添的几个抓取网址才导致出现CPU飙高，通过fastThread进行分析发现有几个线程执行的代码是一样的，但是按照正常流程该段代码只会出现在一个线程，如下图所示：上图标红的这几个线程都是执行最近新添的代码，并且发现都卡在了startHandshake这里，在网上搜索发现也有其它小伙伴遇见这个问题。由于抓取的数据量非常大所以执行的时间会比较久再加上自己手贱在定时执行线程中又包了一个子线程，所以导致了上面出现的几个线程同时执行同一段代码，通过浏览器不用https访问发现一样可以取到数据，然后果断的将后台上的网址换掉。通过优化代码和更换网址后从昨天到今天暂时未发现CPU占用较高的问题 总结 通过这次问题发现，线程一定不要乱用，凡是用到多线程的地方一定要谨慎思考 对于分析问题也会有不少的收获，一些基本的JVM命令需要去了解并在发现问题时知道怎么用。 对于java程序而言，CPU占用过高大多数是因为内存不够，而GC又回收不了导致的]]></content>
      <categories>
        <category>错误分析</category>
      </categories>
      <tags>
        <tag>dump</tag>
        <tag>thread</tag>
        <tag>Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap底层分析]]></title>
    <url>%2F2018%2F07%2F12%2Fjava%2FLinkedHashMap%2F</url>
    <content type="text"><![CDATA[简介 由于LinkedHashMap是在HashMap之上进行的，所以要理解LinkedHashMap需要先了解HashMap的原理。对HashMap的理解可以参考之前写的HashMap分析，LinkedHashMap继承了HashMap，所以LinkedHashMap其实也是散列表的结构，不同的是LinkedHashMap是运用双向链表而HashMap是运用单向链表，通过源代码中的注释可以知道它使用链表来维护数据的有序性。 属性 1234567891011121314//内部静态类，元素的存储结构，继承至HashMap.Node,扩展为一个双向链表static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;//头指针transient LinkedHashMap.Entry&lt;K,V&gt; head;//尾指针transient LinkedHashMap.Entry&lt;K,V&gt; tail;//此属性可以控制元素顺序，默认false,顺序为插入时的顺序//为true时对集合里的数操作时会将数据放入尾部，通过它可以实现LRU缓存final boolean accessOrder; 由于LinkedHashMap继承了HashMap所以其内部属性就比较少，通过head,tail来保存首尾元素，静态类Entry继承Node,并扩展为一个双向链表，通过accessOrder我们可以控制元素的顺序 元素创建 12345678910111213Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);//创建新节点 linkNodeLast(p);//链接节点 return p;&#125;//红黑树方式创建节点TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next); linkNodeLast(p); return p;&#125; 我们知道在put新元素时会通过newNode创建新节点，与HashMap不同的是这里创建节点后会将节点与前一个关联起来12345678910private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail;//保存尾部节点 tail = p;//修改尾部节点为当前新节点 if (last == null)//如果之前的尾部节点为空说明集合里还没有元素 head = p;//修改头节点为当前新节点 else &#123; p.before = last;//设置当前节点的前置节点为原尾部节点 last.after = p;//设置原尾部节点的后置节点为当前节点 &#125;&#125; 通过linkNodeLast方法可以将新元素关联到链表尾部，并将其与前一个节点关联上 关键方法 在HashMap中预留了三个方法给LinkedHashMap,通过这三个方法可以保证链表的插入、删除的有序性123void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;//访问的回调void afterNodeInsertion(boolean evict) &#123; &#125;//插入后的回调void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;//删除后的回调 afterNodeAccess方法1234567891011121314151617181920212223242526void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // 移动节点到尾部 LinkedHashMap.Entry&lt;K,V&gt; last; //如果accessOrder为true且当前访问的节点不是尾节点 if (accessOrder &amp;&amp; (last = tail) != e) &#123; //节点e强转成双向链表节点p,保存前置节点与后置节点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null;//将后置节点置为null if (b == null)//说明原节点是首节点 head = a;//将原节点的后置节点提升为首节点 else b.after = a;//更新p的前置节点b的后置节点为a if (a != null)//p的后置节点不为null a.before = b;//更新p的后置节点a的前置节点为b else//说明原节点就是尾节点 last = b;//更新尾节点为原节点的前置节点b if (last == null)//如果尾节点为空说明链表中就只有一个节点就是p head = p;//更新头节点为p else &#123; p.before = last;//更新当前节点p的前置节点为原尾节点last last.after = p;//更新last的后置节点是p &#125; tail = p;//更新p为链表尾节点 ++modCount; &#125; &#125; 通过afterNodeAccess方法将当前节点移至链表尾部，但有一个条件就是当accessOrder为true时才会执行这个操作，在HashMap的putVal方法中，就调用了这个方法。 afterNodeInsertion方法1234567891011void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 该方法会在链表中插入一个新节点的时候调用，目的是删除链表的首节点，当然需要重写removeEldestEntry方法因为默认是返回false，通过afterNodeAccess方法与afterNodeInsertion方法我们可以实现一个LRU缓存 afterNodeRemoval方法12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; afterNodeRemoval方法主要目的是在移除数据后将双向链表中该节点一并移除掉 get方法12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 该方法与HashMap里的get方法不同的是当accessOrder为true时会回调afterNodeAccess方法 getOrDefault方法12345678 public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return defaultValue; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 该方法会根据key去查找数据，如果没有找到则返回默认值defaultValue，若找到则返回节点数据，最后判断accessOrder是否为true，若是则执行afterNodeAccess方法 containsValue方法12345678public boolean containsValue(Object value) &#123; for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123; V v = e.value; if (v == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; return false;&#125; 该方法比HashMap里的效率要高，HashMap里使用了两个循环，这里只对链表从前往后查找 总结 LinkedHashMap继承了HashMap，所以HashMap存在的问题它也一样会存在 可以利用LinkedHashMap构造一个LRUCache，条件是需要将accessOrder设置为true，并重写removeEldestEntry方法 LinkedHashMap插入的数据是有序的，而HashMap存入的数据是无序的]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList底层分析]]></title>
    <url>%2F2018%2F07%2F11%2Fjava%2FLinkedList%2F</url>
    <content type="text"><![CDATA[简介 LinkedList与ArrayList一样是一个集合类，用于顺序存储元素允许元素为null。 在开发中ArrayList经常被用到， ArrayList 内部采用数组保存元素，适合用于随机访问比较多的场景，而随机插入、删除等操作因为要移动元素而比较慢。 LinkedList 内部采用双向链表的形式存储元素，随机访问比较慢，但是插入、删除元素比较快，LinkedList与ArrayList一样都是线程不安全的，所以要避免在多线程下使用，LinkedList实现了 Deque 所以它也可以作为一个双端队列。 属性 123456//链表节点数transient int size = 0;//指向第一个节点的指针transient Node&lt;E&gt; first;//指向最后一个节点的指针transient Node&lt;E&gt; last; 属性较少就三个，根据上图应该很容易理解first,last的作用 构造器 123456public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 两个构造器，一个什么都没干，另一个调用addAll方法将集合里的所有元素插入链表中，后面会对addAll方法进行详细介绍 节点(Node) 12345678910private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node 是在 LinkedList 里定义的一个静态内部类，其内部结构包括一个数据item，一个后置指针next，一个前置指针prev 添加数据 头部添加123public void addFirst(E e) &#123; linkFirst(e);&#125; 123456789101112private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first;//将首节点赋值给f变量 //创建节点将前置节点设置为null，后置节点指向f final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode;//将当前节点设置为首节点 if (f == null)//代表list里还没有任何节点，所以首节点，尾节点都是当前创建的节点 last = newNode; else f.prev = newNode;//将f的前置节点指向当前节点 size++;//计数自增 modCount++;//修改计数自增 &#125; 头部添加，首先是将原来的首节点赋值给一个临时变量，然后创建新的节点将其前置节点设置为null，值设置为要插入的数据，后置节点设置为f，然后将创建的节点设置首节点，如果当前集合里没有任何数据，则尾节点也将设置为当前创建的节点，否则将f的前置节点设置为当前创建的节点 尾部添加123public void addLast(E e) &#123; linkLast(e); &#125; 123456789101112void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//将尾节点赋值给l变量 //创建新节点，前置节点设置为l,后置节点设置为null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//将新创建的节点赋值给尾部节点 if (l == null)//代表集合里还有任务数据 first = newNode;//首节点也将是为当前节点 else l.next = newNode;//将l后置节点设置为当前新创建的节点 size++;//大小计数自增 modCount++;//修改标识计数自增 &#125; 尾部添加首先是将尾部节点赋值给一个临时变量l，然后创建新的节点其前置节点为l,item为当前要插入的数据，后置节点设置为null，将尾部节点设置创建的节点，如果当前集合里还没有任何数据则首节点也要设置为当前节点，否则将l的后置节点设置为当前创建的节点1234public boolean add(E e) &#123; linkLast(e); return true; &#125; add方法默认就是调用的尾部添加方法，所以与addLast基本上是一样的 指定位置添加12345678public void add(int index, E element) &#123; checkPositionIndex(index);//检查下标是否越界 if (index == size) linkLast(element);//尾部插入 else //指定位置前插入，node方法查找指定位置的节点，内部使用二分查找 linkBefore(element, node(index)); &#125; node方法通过二分查找法查找指定位置节点1234567891011121314Node&lt;E&gt; node(int index) &#123; //size向右移一位，也就是size/2 if (index &lt; (size &gt;&gt; 1)) &#123;//如果指定位置小于size/2则从首节点往后查找 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;//从尾节点往前查找 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; linkBefore方法在succ节点前，插入一个新节点e123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; final Node&lt;E&gt; pred = succ.prev;//保存succ节点的前置节点 //创建新节点，前置节点为pred，item为e,后置节点为succ final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode;//设置succ节点的前置节点为新创建的节点 if (pred == null)//为空则succ为首节点 first = newNode;//将新创建的节点设置首节点 else pred.next = newNode;//将pred的后置节点设置新创建的节点 size++;//大小计数自增 modCount++;//修改标识计数自增 &#125; 指定位置添加数据，先检查下标是否越界，若越界则抛出异常，否则判断指定位置是否为尾部，若是则执行尾部添加数据方法，否则根据二分查找法查找到指定位置的节点，然后在它之前将创建的新节点插入 addAll方法123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);//以size为插入下标，插入集合c中所有元素 &#125; 123456789101112131415161718192021222324252627282930313233public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index);//检查下标是否越界 Object[] a = c.toArray();//集合转为数组 int numNew = a.length;//新增元素数量 if (numNew == 0)//新增元素数量为0则直接返回false return false; Node&lt;E&gt; pred, succ; if (index == size) &#123;//指定位置为链表尾部 succ = null; pred = last;//保存尾节点到pred &#125; else &#123; succ = node(index);//得到指定位置的节点 pred = succ.prev;//保存指定位置节点的前置节点 &#125; for (Object o : a) &#123;//循环遍历数组 @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);//创建新节点 if (pred == null)//代表指定位置为首节点 first = newNode;//将新创建的节点设置为首节点 else pred.next = newNode;//将指定位置节点的前置节点的后置节点指向新创建的节点 pred = newNode;//将新创建的节点赋给pred为下次循环做准备 &#125; if (succ == null) &#123;//代表是在尾部添加的数据 last = pred;//将最后创建的节点设置尾节点 &#125; else &#123; pred.next = succ;//将最后添加的节点的后置节点指向指定位置的节点 succ.prev = pred;//将指定位置的节点的前置节点指向最后添加的数据节点 &#125; size += numNew;//更新大小 modCount++; return true; &#125; addAll方法在指定下标插入集合里的所有元素，首先会判断下标是否越界，若未越界则将集合转为数组得到新添加元素的数量，如果新增元素数量为0则直接返回false，否则判断指定位置是否为链表尾部，若是则依次将集合里的元素添加到尾部，否则添加到指定位置节点的前面，最后更新size 删除数据 头部删除123456public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null)//判断首节点是否为空，若是则抛出异常 throw new NoSuchElementException(); return unlinkFirst(f); &#125; 头部删除数据，首先判断链表首节点是否为null若是代表集合里还没有数据则抛出异常否则执行unlinkFirst方法，源代码中的remove()方法也是采用的头部删除1234567891011121314private E unlinkFirst(Node&lt;E&gt; f) &#123; final E element = f.item;//保存首节点元素 final Node&lt;E&gt; next = f.next;//保存首节点的后置节点 f.item = null;//将元素置为null f.next = null; //后置节点置为null first = next;//将保存的后置节点提升为首节点 if (next == null)//代表集合为空了 last = null; else next.prev = null;//将后置节点的前置节点置为null size--;//大小计数自减 modCount++; return element; &#125; unlinkFirst方法首先会保存链表首节点元素与首节点里的后置节点，然后将首节点的元素与后置节点置为null以便于垃圾回收，将保存的后置节点提升为首节点，如果保存的后置节点为null说明集合里没有数据，需要将链表尾节点置为null，若保存的后置节点不为null则将其前置节点置为null，最后对大小计数自减，修改标识自增并返回删除的元素 尾部删除123456public E removeLast() &#123; final Node&lt;E&gt; l = last;//保存尾部节点 if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; 尾部删除，首先判断尾部节点是否为null，如果则抛出异常，否则执行unlinkLast方法1234567891011121314private E unlinkLast(Node&lt;E&gt; l) &#123; final E element = l.item;//保存节点元素 final Node&lt;E&gt; prev = l.prev;//保存尾节点的前置节点 l.item = null;//将元素置空 l.prev = null; // 将尾节点的前置节点置空 last = prev;//设置保存的前置节点为链表的尾节点 if (prev == null)//代表集合里没有数据 first = null;//首节点了需要置为null else prev.next = null;//设置保存的前置节点的后置节点为null size--;//大小计数自减 modCount++; return element; &#125; unlinkLast方法首先会保存链表尾节点元素与它的前置节点，然后将尾节点的元素与前置节点置为null以便于垃圾回收，将保存的前置节点设置为链表尾节点，如果保存的前置节点为null说明集合里没有数据，需要将链表首节点置为null，若保存的前置节点不为null则将其后置节点置为null，最后对大小计数自减，修改标识自增并返回删除的元素 删除指定元素12345678910111213141516171819public boolean remove(Object o) &#123; //要删除的是null节点(从remove和add 里 可以看出，允许元素为null) if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;//循环遍历 if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; 移除指定元素，首先循环遍历链表找到要移除的数据，然后执行unLink方法123456789101112131415161718192021222324E unlink(Node&lt;E&gt; x) &#123; final E element = x.item;//保存节点的元素 final Node&lt;E&gt; next = x.next;//保存节点的后置节点 final Node&lt;E&gt; prev = x.prev;//保存节点的前置节点 if (prev == null) &#123;//如果前置节点为null说明移除的是链表首节点 first = next;//将后置节点提升为首节点 &#125; else &#123; prev.next = next;//将保存的前置节点的后置节点指向保存的后置节点 x.prev = null;//将移除节点的前置节点置为null利于垃圾回收 &#125; if (next == null) &#123;//说明移除的是尾节点 last = prev;//更新链表尾节点 &#125; else &#123; next.prev = prev;//将保存的后置节点的前置节点指向保存的前置节点 x.next = null;//将移除节点的后置节点置为null利于垃圾回收 &#125; x.item = null;//置空移除的元素 size--;//大小计数自减 modCount++; return element; &#125; unlink方法首先将要移除节点的元素item，前置节点，后置节点都保存到临时变量中，如果保存的前置节点等于null说明移除的是链表首节点，否则将保存的前置节点的后置节点指向保存的后置节点然后将移除节点的前置节点置为null利于垃圾回收，如果保存节点的后置节点为null说明移除的是尾节点，则更新链表的尾节点，否则将保存的后置节点的前置节点指向保存的前置节点，将移除节点的后置节点置为null利于垃圾回收123public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; 删除指定元素第一次出现的元素，其实就是执行了remove方法123456789101112131415161718public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; 删除指定元素最后一次出现的元素，内部是从链表的尾节点往前查找，若找到指定的元素则执行unlink方法 删除指定下标元素1234public E remove(int index) &#123; checkElementIndex(index);//判断下标是否越界，若越界则抛出异常 return unlink(node(index)); &#125; 首先判断下标是否越界，若越界则抛出异常，否则根据node方法找到该下标的节点，然后执行unlink方法 修改元素 1234567public E set(int index, E element) &#123; checkElementIndex(index);//检查是否越界 Node&lt;E&gt; x = node(index);//查找指定下标的元素 E oldVal = x.item;//保存原元素值 x.item = element;//将新值更新到节点上 return oldVal;//返回原值&#125; 执行流程如下： 首先是检查是否越界，若越界则抛出异常 根据node方法查找指定下标的节点 保存节点的元素值，将元素节点值替换成新的 返回旧的元素值indexOf与lastIndexOf 1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; 从链表首节点往后开始查找指定元素，循环遍历链表若找到则返回下标，否则返回-11234567891011121314151617public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; 从链表尾节点往前开始查找指定元素，循环遍历链表若找到则返回下标，否则返回-1 其它方法 12345678public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E element() &#123; return getFirst();&#125; peek与element方法都是取出链表首节点元素1234public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; 取出链表首节点元素并移除首节点123public boolean offer(E e) &#123; return add(e);&#125; 添加元素到链表尾部1234public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125; 添加元素到链表首部1234public boolean offerLast(E e) &#123; addLast(e); return true;&#125; 添加元素到链表尾部1234public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; 取出链表首节点元素1234public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125; 取出链表尾节点元素1234public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; 取出链表首元素并移除首元素1234public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 取出链表尾元素并移除尾元素123public void push(E e) &#123; addFirst(e);&#125; 添加元素到链表首部123public E pop() &#123; return removeFirst();&#125; 移除链表首元素并返回 总结 LinkedList 的底层结构是一个带头/尾指针的双向链表，可以快速的对头/尾节点进行操作 对比ArrayList而言，在指定位置插入和删除元素的效率较高，但查找效率就没有ArrayList高 LinkedList通过下标查找节点时会根据二分查找法进行搜索 LinkedList批量添加数据时是循环遍历数组元素插入节点，而ArrayList则是靠拷贝数组来完成 LinkedList与ArrayList一样都是线程不安全的]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList底层分析]]></title>
    <url>%2F2018%2F07%2F10%2Fjava%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList简介 ArrayList底层是基于数组实现，内部提供了一个Object数组且该数组是不可序列化的，可以动态的增加和减少元素 ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆，实列了List接口提供了相关的添加、删除、修改、遍历等功 ArrayList是线层不安全的，所以应该避免在多线程上使用ArrayList属性 12345678 //默认容量10private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//存入元素的数组，不可序列化 transient Object[] elementData;//实际数据数量private int size; 虽然ArrayList实现了Serializable接口，但elementData并没有参与序列化中，为了达到反序列时elementData有值，ArrayList源码中实现了自己的readObject和writeObject方法，序列化时直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData，之所以不让elementData参与序列化是因为底层数组并不能保证每一个位置都存储得有元素，所以为了避免造成空间浪费，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组 ArrayList构造函数 12345678910111213141516171819202122232425262728//构造一个指定初始容量的空列表public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123;//大于0则创建指定容量的空数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//等于0，将空数组赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;//无参构造函数,默认容量为10public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//构造一个包含指定 collection 的元素的列表public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将collection对象转换成数组，然后赋给elementData elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; //c.toArray很有可能返回的不是Object[].class，可以查看BUG编号为6260652 if (elementData.getClass() != Object[].class)//判断类型是否相等，不相等则进行下面操作 elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; add操作 123456789101112131415161718192021222324252627282930313233public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;//第一次添加元素时，elementData 长度会设置为10private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//修改标识自增1 // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//扩容private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 执行流程如下： ensureCapacityInternal方法保证当前数组大小+1后能存入下一个数据 如果当前数组长度+1大于原数组长度，则执行扩容操作，将容量扩为原来的1.5倍(newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)),并将修改标识modCount自增1 将新元素添加到位于size的位置上后返回TRUE1234567891011121314151617public void add(int index, E element) &#123; //确保index小于当前size且大于0，不满足则抛出异常 rangeCheckForAdd(index); //此处与上面add(E e)方法调用一致 ensureCapacityInternal(size + 1); // Increments modCount!! //将index位置以及后面的元素往后移一个位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); //将新元素插入指定位置 elementData[index] = element; size++;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 这个方法其实add(E e)类似，该方法可以指定位置插入元素，具体的执行逻辑如下： 先执行rangeCheckForAdd方法以确保要插入的索引下标小于数组长度且大于0，如果不满足则抛出异常 ensureCapacityInternal(size + 1);此步骤与add(E e)方法一致 将现有数组要插入的位置上的元素以及后面的元素都往后面移一个位置，完在后将新元素插入指定位置，将数组长度自增1get方法 12345678910 public E get(int index) &#123; //检查下标是否大于数组长度，若是则抛出数组越界异常 rangeCheck(index); return elementData(index); &#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 返回指定位置上的元素 set方法 1234567public E set(int index, E element) &#123; //检查下标是否大于数组长度，若是则抛出数组越界异常 rangeCheck(index); E oldValue = elementData(index);//得到原元素 elementData[index] = element;//修改旧元素为新元素 return oldValue;//返回旧元素&#125; set方法将指定位置元素替换成新元素并返回原来的元素 addAll方法 12345678910public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray();//转换为数组 int numNew = a.length;//得到数组长度 //确保当前size+numNew还有足够的容量存入数据 ensureCapacityInternal(size + numNew); // Increments modCount //插入数据 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 执行流程如下： 首先将集合转为数组 通过ensureCapacityInternal方法来确保当前size+numNew还有足够的容量来存入数据 将数组里的数据拷贝到elementData数组中123456789101112131415public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index);//判断指定位置是否越界 Object[] a = c.toArray();//转换为数组 int numNew = a.length; //确保当前size+numNew还有足够的容量存入数据 ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//先将指定位置以及后面的数据移到 index + numNew位置 //将新的元素拷贝到指定位置 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 执行流程如下： 判断给的位置是否越界，若越界则抛出异常 将集合转换为数组，并进行扩容 如果指定的位置不是elementData数组最后一个则进行位置移动操作 最后将新的元素拷贝到elementData数组中remove方法 1234567891011public E remove(int index) &#123; rangeCheck(index);//索引检查，判断是否越界 modCount++;//修改标识自增 E oldValue = elementData(index);//获得元素 int numMoved = size - index - 1; if (numMoved &gt; 0)//如果不是最后一个元素则进行拷贝操作 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 执行流程如下： 首先检查指定下标是否超过数组大小，若超过则抛出数组越界异常 将modCount自增，获得指定位置的元素，方便最后返回 如果要移除的不是最后一个元素则需要进行数组拷贝操作，将指定位置后面的元素向前移一位 最后将最后一个索引位置设置为NULL好让垃圾回收器回收，并返回移除的元素12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 循环遍历数组里所有对象，得到所要移除对象所在索引位置，然后调用fastRemove方法，执行remove操作12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 将所要移除的元素后面的所有元素往前移一位，并将最后一个位置的元素置空 indexOf方法 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 循环遍历elementData数组中的每一个元素进行比较，若找到则返回元素所在下标，否则返回-1，源码中的contains方法也是借助于此方法完成 writeObject、readObject方法123456789101112131415private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; 由于elementData不能被序列化，所以源代码中实现了writeObject方法将数组中的实际数据写入ObjectOutputStream流中12345678910111213141516171819private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; 在反序列化时，为了保证将实际数据还原到elementData中，源代码中实现了readObject方法，从ObjectInputStream流中将数据还原到elementData中 总结 由于每次添加新元素都会进行扩容操作(底层其实是数组拷贝，很耗性能)，所以如果开发中知道数据的大小时，最好在创建时就给一个固定容量值 ArrayList是线程不安全的，所以不要在多线程中使用，最常见的就是ConcurrentModificationException异常，具体的可以查看源码中iterator的实现 每次扩容都是为原来的1.5倍，这将导致空间浪费，可以通过trimToSize方法将此 ArrayList 实例的容量调整为列表的当前大小 根据源代码中remove方法可知ArrayList可以存储null]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap底层分析]]></title>
    <url>%2F2018%2F07%2F09%2Fjava%2FHashMap%2F</url>
    <content type="text"><![CDATA[基本组成成员 1234567891011121314151617181920//默认容量,数组长度16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//最大容量,数组最大长度static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//负载因子，默认0.75fstatic final float DEFAULT_LOAD_FACTOR = 0.75f;//将链表转为红黑树的阀值，默认为8static final int TREEIFY_THRESHOLD = 8;//将红黑树转为链表的阀值，默认为6static final int UNTREEIFY_THRESHOLD = 6;//Node类型的数组transient Node&lt;K,V&gt;[] table;//实际存储的键值对个数transient int size;//用于迭代防止结构性破坏的标量transient int modCount;//扩容阀值，threshold = loadFactor * capacityint threshold;//负载因子变量final float loadFactor; HashMap 是 Map 的一个实现类，它代表的是一种键值对的数据存储形式,Key 不允许重复出现,但可以储存null键值,在jdk8中其内部是由数组+链表+红黑树来实现 构造方法 123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; HashMap一共有4个构造方法，如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值，initialCapacity默认为16，loadFactory默认为0.75，初始的时候并没有为Node数组分配内存空间，而是在put的时候进行分配 hash的计算 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，而Node数组下标计算则是按照下面方式进行计算：1(n - 1) &amp; hash put方法具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断是否初始了，若没有则初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //判断当前下标是否有数据，没有则存入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //有数据则放入链表尾部 else &#123; Node&lt;K,V&gt; e; K k; //当前节点与要插入的节点为同一个，此时仅仅是修改操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //当前节点是红黑树节点，则以红黑树方式插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //遍历链表，将节点插入尾部 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //判断是否需要将链表变为红黑白树，大于等于8时进行转换 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //添加后，是否达到扩容阀值，如果是则需要进行扩容操作 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 执行流程如下： 判断table数级是否初始化了，如果没有则进行初始化resize() 根据(n - 1) &amp; hash得到数组下标，判断当前索引是否存储得有数据，如果没有则创建node节点并插入 如果上面步骤有数据则判断当前节点是否与将要插入的节点为同一个，如果是则仅仅是修改操作，否则执行下面步骤 判断当前节点是否为红黑树节点，如果是则按照红黑树节点方式插入，否则执行下面步骤 遍历链表，将要插入的节点放入尾部，需要判断是否需要转换为红黑树，若满足要求则进行转换 最后添加节点后需要判断是否需要进行扩容操作get具体实现 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //对table进行校验，判断是否为空，长度是否大于0，取出的数据是否不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //判断当前下标里的第一个节点是否就是所要查找的，若是则直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //第一个节点不是所查找的则遍历查找 if ((e = first.next) != null) &#123; // 若节点是红黑树节点，则按红黑树方式进行查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //遍历链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 执行流程如下： 首选对table数组进行校验，判断是否不等于null,长度是否大于0，取出的数据是否不等于null,若条件满足则执行下面步骤 判断上一步取出的节点里的hash与key是否与当前查找的hash，key相等，如果相等则直接返回当前节点，否则继续往下执行 根据第一节点判断是否为红黑树节点，若是则按红黑树方式进行查找，否则遍历链表进行查找，直到找到为止remove具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //对table进行校验，判断是否为空，长度是否大于0，取出的数据是否不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //判断当前下标里的第一个节点是否就是所要查找的，若是则赋值给局部变量node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123;//若不是所要找的则判断下一节点是否为不等于null if (p instanceof TreeNode)//如果第一个节点为红黑树节点则按红黑树方式查找 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //遍历链表查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //得到所要移除的节点与传入的value进行比较判断是否为同一个 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode)//按照红黑树方式移除 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p)//所要移除的就是首节点则直接将下一个节点提为首节点 tab[index] = node.next; else p.next = node.next;//将所要移除节点的后置节点挂到它前置节点的next上 ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 执行流程如下： 前面部分与get方法类似，先去查找所要称除的节点，唯一不同的是get方法是查找到后直接返回，这里是将值赋值给了局部变量node 得到所要移除的节点后，将其与传入的参数value进行比较，如果条件满足则继续往下面执行 判断所要移除的节点是否为红黑树节点，若是则按红黑树方式进行移除 上一步若不满足，则判断所要移除的节点是否为首节点，若是则将其后置节点提升为首节点 上一步若不满足，则将所要移除节点的后置节点挂到它前置节点的next上resize方法具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //未超过最大值则扩容为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold //使用了initialCapacity参数的构造器，首次扩容则会到这里 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //使用了未带参数的构造器，首次扩容则会到这里 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //旧数组不为 null，这次的 resize 是一次扩容行为 if (oldTab != null) &#123; //遍历方式把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null)//首节点则直接分配 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)//红黑树节点方式分配 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123;//索引值不会发生变化 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123;//索引值发生变化，原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //下面主要是将链表上的数据按照e.hash &amp; oldCap不等0的将分配到原索引+oldCap的链表上 //原索引存入 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap存入 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 执行流程如下： 如果是第一次扩容，首先会根据选用的构造器来进入不同的条件，上面代码中已有注释 循环遍历，将原索引链表上的一部数据分配到新索引链表上，计算方式为（e.hash &amp; oldCap） == 0，如果为0则不发生改变，否则将分配到新索引链表上去，这样做的好处是避免了重新计算hash值，将数据均匀分散减少碰撞几率##总结： 根据分析可知,HashMap内部的储存依赖hash值的计算，所以选用String，Integer这些类做为键会提高HashMap的效率,因为他们本身具备作为键值的天生条件( hashCode(),equal()方法) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap 由于扩容是一个特别耗性能的操作，所以在使用HashMap的时候最好估算下map大小，给一个值避免频繁的进行扩容]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池分析]]></title>
    <url>%2F2018%2F07%2F05%2Fjava%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[为什么需要线程池 线程是稀缺资源，频繁的创建对系统资源消耗较大 线程池可以减少创建和销毁线程的次数并且可以复用线程池的创建 线程池的创建会借助于它的工厂类Executors来创建，主要有如下几种(jdk1.7)： newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 初始化一个只有一个线程的线程池，内部使用的是LinkedBlockingQueue作为阻塞队列，如果该线程异常结束则会创建一个新的线程来继续执行任务，这就保证了所提交的任务顺序执行。 newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 初始化一个指定固定大小的线程池，其中核心线程数与最大线程数是一样的，其内部使用LinkedBlockingQueue作为阻塞队列，当线程池没有可执行任务时，也不会释放线程。 newCachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 初始化一个可缓存线程的线程池，可创建的最大线程数为Integer.MAX_VALUE，内部使用的是SynchronousQueue作为阻塞队列，默认缓存时间为60s，在没有任务可执行时，当线程的空闲时间超过keepAliveTime时会自动释放线程资源，当提交新任务时，如果此时没有空闲的线程，则会创建新线程执行任务，因此会导致一定的系统开销，所以在使用此线程时需要注意并发的任务数，以防创建大量的线程导致性能降低。 newScheduledThreadPool123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据.1、ScheduledExecutorService其中的scheduleAtFixedRate方法，当程序执行时间&lt;频率时间（period）时，则下次执行开始时间=上一次执行开始时间+频率时间（period），当程序执行时间&gt;频率时间（period）时，则会在上一次执行结束后立即进入下一次执行2、ScheduledExecutorService其中的scheduleWithFixedDelay方法,程序会上一次执行结束后等待(period)时间再进行下一次执行 以上几个除了newScheduledThreadPool内部实现使用的是ScheduledThreadPoolExecutor外其它都是基于ThreadPoolExecutor类实现 ThreadPoolExecutor对象 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize：线程池核心线程数（提交新任务时，如果当前线程数小于corePoolSize则会创建新的线程执行任务直到当前线程数等于corePoolSize，如果当前线程数等于corePoolSize则会将新提交的任务放入阻塞队列中，如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程） maximumPoolSize：线程池最大线程数(当前队列已满时，如果线程数小于maximumPoolSize则会创建新的线程执行新提交的任务) keepAliveTime：线程空闲时存活时间，只有当线程数大于corePoolSize时此参数才会生效 unit：时间单位（keepAliveTime） workQueue：保存实现了Runable接口的任务阻塞队列,关于workQueue值jdk提供了以下几种供选择：1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene4、priorityBlockingQuene：优先级无界阻塞队列 threadFactory:创建线程的工厂，可以通过自定义的线程工厂给每个新建的线程设置一个具有识别度的线程名 handler：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了以下几种：1、ThreadPoolExecutor.AbortPolicy：直接抛出RejectedExecutionException异常，默认策略2、ThreadPoolExecutor.DiscardPolicy：直接丢弃任务与AbortPolicy不同的是不会抛出异常3、ThreadPoolExecutor.DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务，并执行当前任务4、ThreadPoolExecutor.CallerRunsPolicy：用调用者所在的线程来执行任务可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略 执行流程 如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务 如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中 如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务 如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略线程池状态 RUNNING：-1&lt;&lt;COUNT_BITS，即高3位为111，低29位为0，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务 SHUTDOWN：0&lt;&lt;COUNT_BITS，即高3位为000，低29位为0，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务 STOP：1&lt;&lt;COUNT_BITS，即高3位为001，低29位为0，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务 TIDYING：2&lt;&lt;COUNT_BITS，即高3位为010，低29位为0，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法 TERMINATED：3&lt;&lt;COUNT_BITS，即高3位为100，低29位为0，terminated()方法调用完成后变成此状态execute 12345678910111213141516171819202122232425public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //根据workerCountOf方法计算出当前线程数，判断当前线程数是否小于核心线程数 if (workerCountOf(c) &lt; corePoolSize) &#123; // 执行addWorker方法创建新的线程执行任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; //执行addWorker失败，判断线程池是否正在运行并且将任务加入队列中 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //再次校验，线程池不是RUNNING状态且成功从阻塞队列中删除任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果当前worker数量为0，通过addWorker(null, false)创建一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false);//未指定firstTask,第二个参数 ? corePoolSize：maxPoolSize &#125; //如果线程池不是运行状态或者进入队列失败，执行addWorker方法 else if (!addWorker(command, false)) reject(command);//addWorker方法执行失败，则拒绝当前command &#125; 执行流程如下 通过workerCountOf方法得到线程池当前线程数，如果当前线程数小于corePoolSize则通过addWorker(command, true)方法创建新worker线程，如创建成功返回，否则继续下面的步骤 如果线程池处于RUNNING状态，且把任务成功放入阻塞队列中,如果加入失败则继续执行后面的步骤1、如果线程池已经不是running状态了且从workQueue中删除任务成功，则拒绝添加新任务2、如果线程池是运行状态，或者从workQueue中删除任务失败且当前worker数量为0则执行addWorker(null, false)创建一个线程 如果线程池不是运行状态或者无法入队列则拒绝添加新任务 addWorker 字面意思就是添加worker线程,主要负责创建新的线程并执行任务,代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //如果线程池状态大于或等于SHUTDOWN且后面三个条件中有一个为false则不会继续进行 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c);//worker数量 //如果worker数量&gt;线程池最大上限CAPACITY //或者( worker数量&gt;corePoolSize 或 worker数量&gt;maximumPoolSize )则返回不再进行曳光弹 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //cas操作，使得worker数量加1 if (compareAndIncrementWorkerCount(c)) break retry;//跳出retry循环 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs)//如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);//创建一个worker线程 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock();//加锁 try &#123; int rs = runStateOf(ctl.get()); //线程池状态小于SHUTDOWN或者（为SHUTDOWN状态且firstTask==null） if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w);//将worker线程加入HashSet中(workers是一个HashSet) //设置最大的池大小largestPoolSize，workerAdded设置为true int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock();//释放锁 &#125; if (workerAdded) &#123;//加入HashSet成功 t.start();//启动线程 workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted; &#125; addWorker执行流程如下： 判断线程池状态是否为可以添加worker线程的状态，如果是则继续下一步，否则返回false 判断线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），如果超过则return false，否则对workerCount+1，继续往下执行 在线程池的ReentrantLock保证下，向Workers中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这几步操作都成功则返回true否则调用addWorkerFailed()逻辑 worker类 线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例添加到HashSet后，并启动Woker中的线程，其中Worker类设计如下：123private final class Worker extends AbstractQueuedSynchronizer implements Runnable 继承了AQS(AbstractQueuedSynchronizer)类，可以方便的实现工作线程的中止操作； 实现了Runnable接口，可以将自身作为一个任务在工作线程中执行； 当前提交的任务firstTask作为参数传入Worker的构造方法创建worker时初始化AQS的状态为-1，将当前提交的任务firstTask作为参数传入构造方法并创建Thread12345Worker(Runnable firstTask) &#123; setState(-1); // 这所以初始化为-1是为了防止被中断 this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; 初始AQS状态为-1，此时不允许中断interrupt()，只有在worker线程启动了，执行了runWoker()，将state置为0，才能中断，为了防止运行中的worker被中断，所以runWorker()每次运行任务时都会lock()上锁，在调用shutdown时会先去获得worker锁后才能再中断这样就防止了中断运行中的worker1234567protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123;//这里不是加1操作而是将state从0设置为1所以规避了重入锁 setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; runWorker 1234567891011121314151617181920212223242526272829303132333435363738394041424344final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // 释放锁,将state置为0，interruptIfStarted只有state&gt;=0时才能调用中断 boolean completedAbruptly = true; try &#123; //如果task不等于null或者从队列中取出的task不等于null while (task != null || (task = getTask()) != null) &#123; w.lock();//上锁，防止调用shutdown时中断正在运行的任务 //两种情况： //1、当前线程池状态&gt;=stop且没有设置中断状态则wt.interrupt //2、如果第一个条件&lt;stop，但线程已经被中断，又清除了中断标示，再次判断线程池状态是否&gt;=stop //如果是则wt.interrupt() if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt();//调用中断操作 try &#123; beforeExecute(wt, task);//任务执行前的操作 Throwable thrown = null; try &#123; task.run();//执行任务 &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown);//任务执行后的操作 &#125; &#125; finally &#123; task = null; w.completedTasks++;//完成任务数+1 w.unlock();//释放锁 &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly);//执行worker退出 &#125; &#125; 执行流程如下： 线程启动后通过释放锁将AQS的state置为0，允许中断当前worker线程 执行firstTask调用task.run()，在执行之前会进行加锁操作，执行完后会释放锁，目的是防止在任务运行时被线程池一些中断操作中断 如果自己的业务需要在任务执行前后进行操作，可以自定义beforeExecute和afterExecute方法 当前任务执行完后，会通过getTask()从阻塞队列中获取新任务，如果队列中没有任务或者获取超时则当前worker则会执行退出流程 getTask 12345678910111213141516171819202122232425262728293031323334private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 如果当前线程池状态&gt;=SHUTDOWN 且(线程池状态&gt;=STOP 或者队列为空)时，会减少worker数量，并返回null if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount();//cas操作减少worker数量，循环操作 return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //wc&gt;maximumPoolSize且队列为空，或者timed与timedOut都为ture且(wc &gt; 1 || 队列为空) if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ://wc &gt; corePoolSize workQueue.take();//wc&lt; corePoolSize if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 执行流程如下： 判断线程池状态是否满足，线程池为shutdown且( workQueue为空或者stop状态)都不满足，则会cas操作减少worker数量并返回null 线程数量是否超过maximumPoolSize或者获取任务超时且(线程数大于1或者队列为空)，则会cas操作减少worker数量并返回null 如果满足获取任务条件，根据是否需要定时获取调用不同方法： 1、workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null 2、workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务 在阻塞从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程 参考资料：Java线程池ThreadPoolExecutor使用和分析]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pool</tag>
      </tags>
  </entry>
</search>
